feiyangqingyun /qtkaifajingyan

1. Когда в компиляции обнаруживается большое количество ошибок, начните с первой и устраняйте их одну за другой. Не спешите увидеть следующую ошибку. Часто последние ошибки вызваны предыдущими ошибками. Могут быть все решено
2. Таймер - хорошая вещь, научитесь его использовать, иногда с помощью одиночного таймера QTimer :: singleShot и QMetaObject :: invokeMethod можно решить неожиданные проблемы. Например, загрузка занимает много времени при инициализации формы, поэтому легко застрять на главном дисплее интерфейса, и интерфейс не будет отображаться до завершения загрузки, что приводит к очень неприятным ощущениям. Загрузка времени (иногда эти загрузки должны выполняться в основном потоке, например, при использовании окна стека QStackWidget для загрузки некоторых подформ), отложенная или асинхронная загрузка, чтобы она выполнялась после отображения интерфейса вместо основного основного интерфейса.
```cpp
//Выполнять функцию загрузки асинхронно
QMetaObject::invokeMethod(this, "load", Qt::QueuedConnection);
//Задержка 10 миллисекунд для выполнения функции загрузки
QTimer::singleShot(10, this, SLOT(load()));
```
3.QtCreator по умолчанию - это однопоточная компиляция. В начале проектирования можно подумать, что он не занимает как можно больше системных ресурсов. В настоящее время компьютеры являются многоядерными. Компилятор msvc по умолчанию - это многопоточная компиляция без ручной настройки. другие компиляторы, вам нужно установить его вручную.
- Метод 1. На этапе сборки параметров сборки каждого проекта (вы можете проверить страницу теневой сборки) добавьте строку -j16 для создания аргументов. Этот параметр будет сохранен в файле pro.user и понадобится, когда он удален Reset, этот метод не рекомендуется;
- Метод 2: Добавьте в среду комплекта сборки, Инструменты-> Параметры-> Комплекты сборки-> Выберите комплект сборки-> среда-> кнопка изменения справа-> Введите MAKEFLAGS = -j4 в открытое поле ввода, В таким образом, вам не нужно каждый раз настраивать многопоточную компиляцию, пока это проект, который использует этот набор компонентов, этот параметр компиляции будет добавлен; 
- Примечание: за -j следует количество ядер компьютера. Если вы напишете слишком много, не будет никакого эффекта. Вы должны проверить параметры компьютера или ввести -j4. Ведь 4 ядра компьютер должен быть самым основным; 
- Вероятно, новая версия QtCreator, начиная с 2019 года, будет автоматически устанавливать многопоточную компиляцию в соответствии с ядром компьютера по умолчанию. Например, если он распознает, что ваш компьютер 16-ядерный, он будет компилироваться с параметром -j16 по умолчанию ; 

4. Если вы хотите использовать QtCreator для беспрепятственного развертывания программ Android, вы должны сначала успешно настроить его в AndroidStudio, чтобы сгладить все неровности. 

5. Много раз после нахождения соответствующего метода инкапсуляции Qt не забывайте больше смотреть на перегрузку функции. Если у вас несколько параметров, вы найдете другой мир, и иногда вы внезапно поймете, что Qt уже инкапсулировал его для us, например, перегруженные параметры QString и QColor чрезвычайно богаты.

6. Вы можете записать номер версии метки + значок ico в файл pro (поддерживается только Qt5) .На самом деле, когда это qmake в Windows, эта информация будет автоматически преобразована в файл rc. 

```cpp
VERSION  = 2025.10.01
RC_ICONS = main.ico
```

7. Администратор запускает программу, ограниченную компилятором MSVC. 
```cpp
QMAKE_LFLAGS += /MANIFESTUAC:"level='requireAdministrator' uiAccess='false'" #Запустить от имени администратора
QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,"5.01" # VS2013 Запуск на XP
```
8. В рабочем файле есть окно вывода отладки. Это очень полезно. Много раз, когда мы выпускаем программу, мы сталкиваемся с тем, что программа дважды щелкает и не запускается без сообщения об ошибке (на машине разработки все в норме. ), и мы не знаем, что произошло, или даже о задаче. Менеджер видит, что она запущена, но интерфейс не появляется. В это время вам нужно добавить это в файл pro проекта. Программа с интерфейсом также автоматически откроет окно отладки, чтобы распечатать информацию, которая удобна для поиска проблем. Как правило, он не может работать нормально. Программа будет печатать некоторые подсказки и так далее. 
```cpp
TEMPLATE    = app
MOC_DIR     = temp/moc
RCC_DIR     = temp/rcc
UI_DIR      = temp/ui
OBJECTS_DIR = temp/obj
# Следующая строка используется для установки рабочего файла с окном вывода отладки 
CONFIG      += console
```
9. Нарисуйте мозаичный фон QPainter :: drawTiledPixmap и нарисуйте прямоугольник с закругленными углами QPainter :: drawRoundedRect () вместо QPainter :: drawRoundRect (); 
10. Удалить старый стиль 
```cpp
//Удалить исходный стиль 
style()->unpolish(ui->btn);
//Должна быть следующая строка, иначе он не будет удален 
ui->btn->setStyleSheet("");
//Сбросьте новый стиль элемента управления.
style()->polish(ui->btn);
```

11.Получить атрибуты класса
```cpp
const QMetaObject *metaobject = object->metaObject();
int count = metaobject->propertyCount();
for (int i = 0; i < count; ++i) {
    QMetaProperty metaproperty = metaobject->property(i);
    const char *name = metaproperty.name();
    QVariant value = object->property(name);
    qDebug() << name << value;
}
```

12. Встроенные значки Qt инкапсулированы в QStyle, и существует около 70 значков, которые можно использовать напрямую. 
```cpp
SP_TitleBarMenuButton,
SP_TitleBarMinButton,
SP_TitleBarMaxButton,
SP_TitleBarCloseButton,
SP_MessageBoxInformation,
SP_MessageBoxWarning,
SP_MessageBoxCritical,
SP_MessageBoxQuestion,
...
//Просто вытащите его и используйте вот так

QPixmap pixmap = this->style()->standardPixmap(QStyle::SP_TitleBarMenuButton);
ui->label->setPixmap(pixmap);

```
13. Оценивайте загрузку по количеству битов операционной системы.
```cpp
win32 {
    contains(DEFINES, WIN64) {
        DESTDIR = $$PWD/../bin64
    } else { 
        DESTDIR = $$PWD/../bin32
    }
}
```

14. Qt5 значительно улучшил проверку безопасности.Если появляется setGeometry: Unable to set geometry, переместите видимость элемента управления после добавления его в макет. 
15. Вы можете добавить элемент управления A в макет, а затем элемент управления B, чтобы задать макет. Такая гибкость улучшает комбинацию элементов управления. Например, вы можете добавить кнопку поиска слева и справа от текстового поля, а кнопку можно установить значок.
```cpp
QPushButton *btn = new QPushButton;
btn->resize(30, ui->lineEdit->height());
QHBoxLayout *layout = new QHBoxLayout(ui->lineEdit);
layout->setMargin(0);
layout->addStretch();
layout->addWidget(btn);
```

16. Чтобы установить стиль элемента управления QLCDNumber, вам необходимо установить стиль сегмента QLCDNumber на плоский, иначе вы не обнаружите никакого эффекта.

17. Умное использование findChildren позволяет находить все дочерние элементы управления под элементом управления. findChild - найти сингл.
```cpp
//Найдите элемент управления с указанным именем класса objectName
QList<QWidget *> widgets = fatherWidget.findChildren<QWidget *>("widgetname");

//Найти все QPushButton
QList<QPushButton *> allPButtons = fatherWidget.findChildren<QPushButton *>();

//Найдите подэлемент управления первого уровня, иначе он всегда будет проходить через все подэлементы управления.
QList<QPushButton *> childButtons = fatherWidget.findChildren<QPushButton *>(QString(), Qt::FindDirectChildrenOnly);

```
18. Используйте наследование с умом, чтобы определить, принадлежит ли оно к определенной категории.
`` cpp
QTimer * timer = new QTimer; // QTimer наследует QObject

timer-> inherits ("QTimer"); // возвращает истину

timer-> inherits ("QObject"); // возвращает истину

timer-> inherits ("QAbstractButton"); // возвращает false
`` '' 

19. Используя механизм слабых атрибутов, временные значения могут быть сохранены для принятия решения о передаче. Вы можете перечислить все имена слабых свойств с помощью widget-> dynamicPropertyNames (), а затем получить значение соответствующего слабого свойства с помощью widget-> property ("name"). 
20. Во время разработки, будь то для удобства обслуживания или из соображений экономии ресурсов памяти, должен быть файл qss для хранения всех таблиц стилей, а setStyleSheet не следует писать везде. Если это начальный этап или этап тестирования, вы можете щелкнуть правой кнопкой мыши пользовательский интерфейс, чтобы установить таблицу стилей.Для формальных проектов лучше объединить файл таблицы стилей в файл таблицы стилей qss для унифицированного управления. 
21. Если появляется сообщение об ошибке Z-order_assignment: is_not_a_valid_widget., Откройте соответствующий файл пользовательского интерфейса с помощью Блокнота, найдите место, где <zorder> </zorder> пуст, и удалите его.
22. Уметь использовать второй параметр addItem ComboBox для установки пользовательских данных, которые могут дать множество эффектов, и использовать _itemData, чтобы получить их.
23.  Если используется модуль webengine, принесите QtWebEngineProcess.exe + папку переводов + папку ресурсов при публикации программы. 
24.  По умолчанию Qt является дескриптором окна.Если вы хотите, чтобы каждый элемент управления имел независимый дескриптор, установите a.setAttribute (Qt :: AA_NativeWindows); 
25.  Qt + Android предотвращает закрытие программы. 
```cpp
#if defined(Q_OS_ANDROID)
QAndroidService a(argc, argv);
return a.exec()
#else
QApplication a(argc, argv);
return a.exec();
#endif
```
26. Вы можете установить стиль общего индикатора вместо индивидуальной настройки индикатора для каждого элемента управления.
```cpp
*::down-arrow{}
*::menu-indicator{}
*::up-arrow:disabled{}
*::up-arrow:off{}
```
27. Вы можете установить фоновое изображение в указанном месте. 
```cpp
QMainWindow > .QWidget {
    background-color: gainsboro;
    background-image: url(:/images/pagefold.png);
    background-position: top right;
    background-repeat: no-repeat
}
```
28. Встроенный Linux, работающий с программой Qt 
```cpp
//Написание Qt4
./HelloQt -qws &

//Формулировка Qt5 xcb может быть изменена на linuxfb eglfs vnc wayland и т. Д., Используйте то, что нужно для тестирования, по очереди
./HelloQt --platform xcb
./HelloQt --platform wayland
```
29. Файл конфигурации программного обеспечения Qtcreator хранится по адресу: C: \ Users \ Administrator \ AppData \ Roaming \ QtProject. Иногда, если что-то пойдет не так, удалите эту папку и откройте создатель, чтобы автоматически восстановить ее. 
30. QMediaPlayer - это оболочка (также может называться фреймворком), использующая локальный декодер, видео в основном воспроизводит MP4 по умолчанию, и даже MP4 не может быть воспроизведен. Если вы хотите поддерживать другие форматы, вам необходимо загрузить k -lite или LAV Filters и установите его. (K-lite или LAV Filters относятся к окнам, ищите в других системах самостоятельно, похоже, что встроенный linux полагается на GStreamer, который не был полностью проверен). Если вам нужен мощный проигрыватель, новички рекомендуют использовать vlc, mpv и окончательный универсальный метод с использованием ffmpeg (декодированное видео можно нарисовать с помощью QOpenGLWidget с помощью графического процессора или преобразовать в QImage для рисования, а аудиоданные можно воспроизвести с помощью QAudioOutput).
31. Определите тип компилятора, версию компилятора и операционную систему.
```cpp
//Компилятор GCC
#ifdef __GNUC__
#if __GNUC__ >= 3   // GCC3.0  выше

//Компилятор MSVC
#ifdef _MSC_VER
#if _MSC_VER >=1000 // VC++4.0 выше
#if _MSC_VER >=1100 // VC++5.0 выше
#if _MSC_VER >=1200 // VC++6.0 выше
#if _MSC_VER >=1300 // VC2003  выше
#if _MSC_VER >=1400 // VC2005  выше
#if _MSC_VER >=1500 // VC2008  выше
#if _MSC_VER >=1600 // VC2010  выше
#if _MSC_VER >=1700 // VC2012  выше
#if _MSC_VER >=1800 // VC2013  выше
#if _MSC_VER >=1900 // VC2015  выше

//Borland C++
#ifdef __BORLANDC__

//Cygwin
#ifdef __CYGWIN__
#ifdef __CYGWIN32__

//mingw
#ifdef __MINGW32__

//windows
#ifdef _WIN32           //32bit
#ifdef _WIN64           //64bit
#ifdef _WINDOWS         //Программа с графическим интерфейсом
#ifdef _CONSOLE         //Консольная программа

//Windows（95/98/Me/NT/2000/XP/Vista）И Windows CE определила
#if (WINVER >= 0x030a)  // Windows 3.1 выше
#if (WINVER >= 0x0400)  // Windows 95/NT4.0 выше
#if (WINVER >= 0x0410)  // Windows 98 выше
#if (WINVER >= 0x0500)  // Windows Me/2000 выше
#if (WINVER >= 0x0501)  // Windows XP выше
#if (WINVER >= 0x0600)  // Windows Vista выше

//_WIN32_WINNT версия ядра
#if (_WIN32_WINNT >= 0x0500) // Windows 2000 выше
#if (_WIN32_WINNT >= 0x0501) // Windows XP выше
#if (_WIN32_WINNT >= 0x0600) // Windows Vista выше

```

32. Определите версию Qt и количество пакетов сборки в pro 
```cpp
# Распечатать информацию о версии
message(qt version: $$QT_VERSION)
# Оценка текущего номера версии qt
QT_VERSION = $$[QT_VERSION]
QT_VERSION = $$split(QT_VERSION, ".")
QT_VER_MAJ = $$member(QT_VERSION, 0)
QT_VER_MIN = $$member(QT_VERSION, 1)
# Следующее для Qt5.5 и выше
greaterThan(QT_VER_MAJ, 4) {
greaterThan(QT_VER_MIN, 4) {
# Выполните некоторую обработку в соответствии с вашими потребностями
}}

#QT_ARCH является новым в Qt5 и не влияет на Qt4
# Распечатать информацию о текущем комплекте сборки Qt
message($$QT_ARCH)
# Указывает комплект сборки платформы _arm
contains(QT_ARCH, arm) {}
# Указывает на 32-битный комплект сборки
contains(QT_ARCH, i386) {}
# Указывает на 64-битный комплект сборки
contains(QT_ARCH, x86_64) {}

# Фактически, Qt имеет встроенные переменные номера основной версии и номера подверсии
# Оценка текущего номера версии qt
message($$QT_ARCH : $$QT_VERSION -> $$QT_MAJOR_VERSION . $$QT_MINOR_VERSION)

# Значение ниже, если версия <4.8
lessThan(QT_MAJOR_VERSION, 5) {
lessThan(QT_MINOR_VERSION, 8) {
# Здесь нужно выполнить обработку
}}

# Значение ниже, если версия> = 5.5
greaterThan(QT_MAJOR_VERSION, 4) {
greaterThan(QT_MINOR_VERSION, 4) {
# Здесь нужно выполнить обработку
}}

// Не судите версию в коде слишком просто
#if (QT_VERSION >= QT_VERSION_CHECK(6,0,0))
// Вот что делать
#endif
```

33. После сворачивания Qt интерфейс будет восстановлен до зависания и зависания, плюс код
```cpp
void showEvent(QShowEvent *e)
{
    setAttribute(Qt::WA_Mapped);
    QWidget::showEvent(e);
}
```
34. Получите высоту строки заголовка: style () -> pixelMetric (QStyle :: PM TitleBarHeight); Щелкните PM TitleBarHeight, и вы найдете новый мир.
35. Установите свойства экрана с высоким разрешением для поддержки высоких разрешений, таких как 2K4K, особенно для мобильных телефонов. app。Должен быть написан на main   Функциональный QApplication a(argc, argv);Спереди.
```cpp
#if (QT_VERSION > QT_VERSION_CHECK(5,6,0))
    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
#endif
    QApplication a(argc, argv);
```
36. Если запущенная программа появляется Fault tolerant heap shim applied to current process. This is usually due to previous crashes.Ошибка。
- Шаг 1: введите команду regedit Откройте реестр；
- Шаг 2: Найдите узел HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers\；
- Шаг 3: выберите Layers Ключ-значение, удалите собственный путь к программе из списка справа.
37. Встроенная в Qt компоновка формы QFormLayout используется для автоматической генерации интерфейса формы комбинации метки + поля ввода. Она редко используется для установки компоновки, и наиболее часто используются горизонтальная компоновка, вертикальная компоновка и компоновка таблицы. .
38. Qml для воспроизведения видео необходимо установить в Linux sudo apt-get install libpulse-dev.
39. Вы можете напрямую наследовать QSqlQueryModel для реализации пользовательской модели QueryModel, такой как цвет шрифта столбца, заполнитель, другие стили и т. Д., И переписать QVariant CustomSqlModel :: data (const QModelIndex & index, int role) const.
40. После Qt5 предоставляется класс QScroller для прямой прокрутки элемента управления.
```cpp
//Отключить горизонтальную полосу прокрутки
ui->listWidget->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//Отключить вертикальную полосу прокрутки
ui->listWidget->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//Установите горизонтальную прокрутку в соответствии со значением пикселя
ui->listWidget->setHorizontalScrollMode(QListWidget::ScrollPerPixel);
//Установите вертикальную прокрутку в соответствии со значением пикселя
ui->listWidget->setVerticalScrollMode(QListWidget::ScrollPerPixel);
//Установите объект прокрутки и метод прокрутки для прокрутки левой кнопкой мыши
QScroller::grabGesture(ui->listWidget, QScroller::LeftMouseButtonGesture);
//Также есть QScrollerProperties, который может устанавливать некоторые параметры прокрутки.
```

41. Если вы не хотите создавать файл базы данных при использовании базы данных sqlite, вы можете создать базу данных в памяти.
```cpp
QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE");
db.setDatabaseName(":memory:");
```
42. Очистите таблицу данных и сбросьте самоинкремент ID，sql = truncate table table_name。

43. Qtchart Модуль от Qt5.7 Он идет вместе с ним, а минимальная компиляция требует Qt5.4. Не забудьте проверить это во время установки, по умолчанию он не отмечен. Использование этого модуля требует введения пространства имен.
```cpp
#include <QChartView>
QT_CHARTS_USE_NAMESPACE
class CustomChart : public QChartView
```
44. QPushButton Текст с выравниванием по левому краю, необходимо установить таблицу стилей QPushButton{text-align:left;}

45. QLabel Есть три способа установить текст, освоить систему атрибутов Qt и сделать выводы друг из друга, вы можете добиться множества эффектов.
```cpp
//Традиционный подход
ui->label->setText("hello");
//Трюки
ui->label->setProperty("text", "hello");
//Атрибут Дафа
ui->label->setStyleSheet("qproperty-text:hello;");
```
46. Умное использование QEventLoop Включение цикла обработки событий может привести к синхронному извлечению и возврату результатов без блокировки интерфейса. Проверьте исходный код, оказывается QEventLoop Выполнение потока создается заново внутри.
```cpp
QEventLoop loop;
connect(reply, SIGNAL(finished()), &loop, SLOT(quit()));
loop.exec();
```

47. Несколько предопределенных переменных #if (defined webkit) || (defined webengine)，Удалите сгенерированный пустой debug и release содержание CONFIG -= debug_and_release。

48. Новая версия Qtcreator Расширенная проверка грамматики, появится много предупреждений и т. Д., Можно закрыть в списке плагинов clang Только первые несколько ，Help》About Plugins。Вы также можете установить уровень проверки кода，Tools》Options 》C++ 》Code Model。
49. QSqlTableModel из rowCount Метод, максимальная доходность по умолчанию 256，Если он превышает 256，Вы можете потянуть стол вниз, он автоматически загрузит оставшиеся, каждый раз самая большая загрузка 256 Данные панели. Если вам нужно распечатать или экспортировать данные, помните, что лучше всего использовать sql Заявление для просмотра вместо использования QSqlTableModel из rowCount метод. В противном случае это всегда будет самый крупный и единственный экспорт. 256 Данные статьи.
Если объем данных невелик, можно также использовать следующие методы:
```cpp
//Активно загружать все данные, иначе количество строк получится<=256
while(model->canFetchMore()) {
    model->fetchMore();
}
```

50. Если вам нужно указать окно без полей, но вам нужно сохранить характеристики границ операционной системы, вы можете свободно растянуть границу, вы можете использовать setWindowFlags(Qt::CustomizeWindowHint);
51. В некоторых http post При отправке данных, если вы используете для отправки данные соединения _string, если китайский язык анализирует искаженные символы, вам необходимо перекодировать китайский URL.
```cpp
QString content = "测试中文";
QString note = content.toUtf8().toPercentEncoding();
```

52. Qt По умолчанию большие файлы ресурсов не поддерживаются. Например, если добавляются файлы шрифтов, вам потребуется pro Файл открыт。
CONFIG += resources_big


53. После наследования QWidget в Qt таблица стилей не работает.Есть три решения. Настоятельно рекомендуется первый метод.
- Метод 1: установить атрибут this-> setAttribute (Qt :: WA_StyledBackground, true);
- Метод 2: изменить наследование QFrame, потому что QFrame имеет свою собственную функцию paintEvent, которая была реализована, и она будет проанализирована и отрисована при использовании таблицы стилей.
- Метод 3: при повторной реализации функции paintEvent QWidget использовать для рисования QStylePainter. 
```cpp
void Widget::paintEvent(QPaintEvent *)
{
    QStyleOption option;
    option.initFrom(this);
    QPainter painter(this);
    style()->drawPrimitive(QStyle::PE_Widget, &option, &painter, this);
}
```

54. Иногда к интерфейсу добавляется пружина, и стратегию растяжения, соответствующую пружине, необходимо динамически изменять. Соответствующий метод - changeSize，Многие люди предпочтут использовать set Я нашел это в начале, я не мог найти。
55. В процессе использования QFile не рекомендуется часто открывать файл для записи, а затем закрывать файл. Например, выводить журнал каждые 5 мсек. Узкое место производительности ввода-вывода очень велико. В этом случае рекомендуется открывать файл сначала и не закрывайте его, и дождитесь подходящего времени, такого как деструктор.Закройте файл, когда файл журнала необходимо снова изменить, когда изменилась дата. В противном случае открытие и закрытие большого количества файлов за короткий промежуток времени будет очень зависнуть, чем больше файл, тем больше зависает.
56. Во многих сетевых приложениях для поддержания соединения требуется настраиваемый контрольный пакет. В противном случае отключится питание или программа будет незаконно закрыта, и другая сторона не сможет ее распознать. Требуется обнаружение тайм-аута. Однако некоторые программы не обеспечивают протокол подтверждения. В настоящее время необходимо включить поддержку активности на уровне системы. Процедура, этот метод подходит для TCP-соединения.
```cpp
int fd = tcpSocket->socketDescriptor();
int keepAlive = 1;      //Включить атрибут keepalive, значение по умолчанию: 0 (закрыто)
int keepIdle = 5;       //Если нет взаимодействия с данными в течение 5 секунд, обнаружение будет выполнено, значение по умолчанию: 7200 (с)
int keepInterval = 2;   //Интервал времени для отправки пакетов обнаружения во время обнаружения составляет 2 секунды, значение по умолчанию: 75 (с).
int keepCount = 2;      //Количество повторных попыток обнаружения, если все таймауты, соединение считается недействительным, значение по умолчанию: 9 (раз)
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&keepAlive, sizeof(keepAlive));
setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, (void *)&keepIdle, sizeof(keepIdle));
setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, (void *)&keepInterval, sizeof(keepInterval));
setsockopt(fd, SOL_TCP, TCP_KEEPCNT, (void *)&keepCount, sizeof(keepCount));
```
57. Если программа упакована, появится всплывающее окно This application failed to start because it could not find or load the Qt platform plugin 一Обычно это вызвано тем, что каталог плагинов платформы не упакован или упакован неправильно.


58. Не рекомендуется включать китайский язык в tr. Хотя новая версия Qt поддерживает перевод с китайского на другие языки, он не стандартизирован, и я не знаю, кто преподавал TMD. Первоначальное значение tr - включить английский, а затем перевести его на другие языки, такие как китайский. В настоящее время большое количество новичков злоупотребляют tr. Если нет необходимости в переводе, tr отключен, а tr требует накладных расходов. По умолчанию Qt будет думать, что ему нужен перевод, и выполнит дополнительная специальная обработка.
59. Многие люди глупо не знают разницы между Qt и Qt Creator. Они часто спрашивают, какая версия Qt и результат - версия Qt Creator. Qt Creator - это интегрированная среда разработки IDE, написанная Qt. вселенная, это может быть компилятор msvc (Qt Cerator, который поставляется с интегрированной установочной средой Qt, соответствующей WIN, - это msvc), он также может быть скомпилирован с помощью mingw или gcc. Если это подключаемый модуль настраиваемого элемента управления, он должен быть интегрирован в Qt Creator, а компилятор, соответствующий файлу динамической библиотеки (файл dll или другой) подключаемого модуля, должен быть точно таким же, как версия Qt и версия количество бит и версию Qt Creator, иначе вряд ли он будет интегрирован. Особое внимание уделяется версии Qt в установочном пакете интегрированной среды Qt, и версия Qt Creator может быть не совсем такой же, вы должны держать глаза открытыми, чтобы ясно видеть, некоторые из них точно такие же.
60. Рекомендуется писать отдельные функции для более чем двух одинаковых кодов обработки. Код должен быть как можно более стандартным и кратким. Например, ``if (a == 123)`` нужно записать как ``if (123 == a)`` со значением впереди и, например, ``if (ok == true)`` следует писать как ``if (ok)`` ,``if (ok == false)``следует писать как`` if (! ok) ``и т. д.
61. Многие люди спрашивают, какая встроенная платформа Qt лучше, и вот единый ответ (текущий узел времени 2018): imx6 + 335x относительно стабилен, высокая производительность, используйте RK3288 RK3399, если это дешево, используйте Allwinner H3, поиграйте с Raspberry Pie апельсиновый пирог.
62. Для большого фрагмента кода комментария рекомендуется использовать #if 0 #endif, чтобы включить блок кода, вместо того, чтобы выбирать код и комментировать все его двойными косыми чертами. Если вы хотите открыть этот код в следующий раз, вам нужно повторно выбрать его и отмените снова. Если вы используете #if 0, вам нужно только изменить 0 на 1, что значительно повысит эффективность разработки.
63. Есть много способов упаковать и выпустить Qt. После Qt5 он предоставляет упаковочный инструмент windeployqt (linuxdeployqt в Linux, macdeployqt в Mac), который может быть очень удобным для упаковки приложений. После его использования он не всемогущ. больше пакетов.Зависимые файлы, иногда вы забываете упаковать некоторые плагины, особенно когда используется qml, и сторонние библиотеки не могут быть распознаны.Например, если программа зависит от ffmpeg, соответствующую библиотеку нужно скопировать самостоятельно . Самый лучший метод - скопировать исполняемый файл. Скопировать его в каталог bin в каталоге установки Qt, а затем упаковать весь пакет вместе и удалить компоненты, которые вряд ли будут зависеть от одного за другим, пока нормальная операция не будет удалена. .
64. Анимация в Qt, нижний уровень использует таймер QElapsedTimer для завершения обработки, такой как генерация некоторых данных определенного алгоритма правила, а затем обработка атрибутов.
65. При рисовании круга без цвета фона и только с цветом границы вы можете заменить его дугой на 360 градусов, и эффект будет точно таким же.
```cpp
QRect rect(-radius, -radius, radius * 2, radius * 2);
//Выберите один из следующих двух методов. На самом деле, рисование дуги на 360 градусов = рисование круга без фона.
painter->drawArc(rect, 0, 360 * 16);
painter->drawEllipse(rect);
```
66. Не смотрите на указатель d очень загадочно. Фактически, частный класс определен в файле реализации класса для хранения локальных переменных. Я лично считаю, что при выполнении некоторых небольших проектов нет особой необходимости вводить этот механизм , что снизит производительность кода.Читаемость увеличивает сложность, и новички будут сбиты с толку после принятия проекта.
67. Когда многие люди рисуют, настраивая кисть, они думают, что могут установить только монотонный цвет. Фактически, QPen также может настраивать кисть, поэтому гибкость увеличивается во много раз. Например, после настройки кисти QPen, вы можете использовать различные градиенты, например, рисовать индикаторы выполнения и текст в градиентных цветах вместо монотонного цвета.
68. Многие элементы управления имеют область просмотра, например QTextEdit / QTableWidget / QScrollArea. Иногда, когда эти элементы управления обрабатываются напрямую, обнаруживается, что это не работает. Вам необходимо установить viewport (). Например, чтобы установить фон прокрутки Чтобы область полосы была прозрачной, вам необходимо использовать scrollArea-> viewport () -> setStyleSheet ("background-color: transparent;"); вместо scrollArea-> setStyleSheet ("QScrollArea {background-color: transparent;}");
69. Иногда для setMouseTracking отслеживания мыши задано значение true. Если в форме есть другие элементы управления, когда мышь перемещается к другим элементам управления, родительское событие движения мыши MouseMove не может быть распознано. В это время необходимо событие HoverMove. Сначала установите setAttribute (Qt :: WA_Hover, истина);
70. Класс даты и времени QDateTime, инкапсулированный в Qt, очень мощный: он может преобразовывать строки символов и дату и время, преобразовывать миллисекунды в дату и время, а также преобразовывать прошедшие 1970 секунд в дату и время.
```cpp
QDateTime dateTime;
QString dateTime_str = dateTime.currentDateTime().toString("yyyy-MM-dd hh:mm:ss");
//Преобразование из строки в миллисекунды (требуется полный год, месяц, день, час, минута и секунда)
datetime.fromString("2011-09-10 12:07:50:541", "yyyy-MM-dd hh:mm:ss:zzz").toMSecsSinceEpoch();
//Преобразование из строки в секунды (требуется полный год, месяц, день, час, минута и секунда)
datetime.fromString("2011-09-10 12:07:50:541", "yyyy-MM-dd hh:mm:ss:zzz").toTime_t();
//Преобразование из миллисекунд в год, месяц, день, час, минуту и ​​секунду
datetime.fromMSecsSinceEpoch(1315193829218).toString("yyyy-MM-dd hh:mm:ss:zzz");
//Преобразование из секунд в год, месяц, день, час, минуту и ​​секунду (если есть zzz, то это 000)
datetime.fromTime_t(1315193829).toString("yyyy-MM-dd hh:mm:ss[:zzz]");
```
71. В процессе использования связанных списков или массивов, таких как ``QList``, ``QStringList``, ``QByteArray`` и т. Д., Если вам нужно только получить значения вместо присвоения значений, настоятельно рекомендуется использовать at () вместо оператора []. В официальной книге «Программирование на C ++ GUI Qt 4» (второе издание) «этой книге сделан особый акцент. Утверждается, что первоначальный автор этого учебника написан основными разработчиками Qt, поэтому он по-прежнему является относительно авторитетным. для сравнения скорости и эффективности использования ``at ()`` и использования оператора ``[]`` Некоторые пользователи сети сделали такое сравнение в Интернете. Исходный текст находится на странице 212 книги. Он описывается следующим образом: Qt использует неявное совместное использование для всех контейнеров и многих других классов. Неявное совместное использование является гарантией Qt того, что данные, которые не нужно изменять, никогда не будут скопированы, чтобы чтобы сделать неявное совместное использование. Чтобы играть лучшую роль, вы можете принять два новых навыка программирования. Первая привычка - использовать функцию at () вместо оператора [] при выполнении доступа только для чтения к (непостоянному) вектору или списку, потому что контейнерный класс Qt не может определить, появится ли оператор [] в Левая часть присваивания остается правой. Он предполагает, что имеет место наихудший случай, и обеспечивает глубокое присваивание, в то время как функция at () не может появляться в левой части присваивания.
72. Если это диалоговая форма, вам необходимо разрешить выполнение других кодов после exec. Добавьте строку кода перед диалоговой формой exec, иначе сообщение формы будет заблокировано.
```cpp
QDialog dialog;
dialog.setWindowModality(Qt::WindowModal);
dialog.exec();
```
73. Чтобы безопасно удалить классы объектов Qt, настоятельно рекомендуется использовать deleteLater вместо delete, потому что deleteLater выберет выпускать его в нужное время, а delete освободит его немедленно, что может вызвать ошибку и сбой. Если вы хотите удалить коллекцию объектов партиями, вы можете использовать qDeleteAll, например qDeleteAll (btns);
74. В элементе управления QTableView, если вам нужно настроить кнопки столбцов, флажки, раскрывающиеся списки и другие режимы для отображения, вы можете использовать для этого настраиваемый делегат QItemDelegate. Если вам нужно отключить столбец, вы можете вернуться в настраиваемом Перегруженная функция createEditor 0 делегата в порядке. Элемент управления, соответствующий настраиваемому делегату, появляется при входе в состояние редактирования.Если вы хотите, чтобы он продолжал отображаться, вам нужно перегрузить функцию рисования, чтобы рисовать с помощью drawPrimitive или drawControl.
75. Ознакомьтесь с ``drawPrimitive, drawControl, drawItemText, drawItemPixmap`` и другими методами, соответствующими ``QApplication :: style ()``. В сочетании со свойством QStyleOption вы можете воспроизводить различные пользовательские комиссии, и вы можете напрямую использовать рисовальщик в функции рисования для выполнения различных Рисование, всевозможные классные таблицы, древовидные списки, выпадающие списки и т. д. обязательно взорвутся. Если четвертый параметр ``QApplication :: style () -> drawControl`` не установлен, нарисованный элемент управления не будет применять таблицу стилей.
76. В уме есть координаты, все - художник. Настоятельно рекомендуется, чтобы при обучении рисованию пользовательских элементов управления вы прочитали, попытались понять все функции в файле заголовка qpainter.h. Это включает в себя все встроенные рисунки интерфейсы Qt. Попробуйте соответствующие параметры еще раз, и вы обнаружите много новых миров, которые в определенной степени будут стимулировать ваш интерес к рисованию, точно так же, как волшебная кисть Ма Лян, верхом на лошади путешествовать по миру рисования кода.
77. 在В процессе использования setItemWidget или setCellWidget иногда обнаруживается, что элемент управления set не отображается в центре, а по умолчанию выровнен по левому краю и не будет автоматически растягиваться и заполняться. Для программистов, стремящихся к совершенству, это не очень красиво , у него есть окончательный вариант. Общий метод состоит в том, чтобы поместить этот элемент управления в макет виджета, а затем добавить виджет к элементу, это идеальное решение, и оно может объединять несколько элементов управления для создания сложных элементов управления.
```cpp
// Создание экземпляра элемента управления индикатора выполнения
QProgressBar *progress = new QProgressBar;
// Добавляем макет виджета, чтобы грамотно добиться центрирования
QWidget *widget = new QWidget;
QHBoxLayout *layout = new QHBoxLayout;
layout->setSpacing(0);
layout->setMargin(0);
layout->addWidget(progress);
widget->setLayout(layout);
ui->tableWidget->setCellWidget(0, 0, widget);
```
78. Во многих случаях необходимо четко нарисовать текст, когда известен цвет фона. В это время необходимо рассчитать соответствующий цвет текста.
```cpp
// Автоматически вычислить соответствующий цвет переднего плана в соответствии с цветом фона
double gray = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255;
QColor textColor = gray > 0.5 ? Qt::black : Qt::white;
```

79. Отключите перетаскивание столбца для QTableView или QTableWidget.
```cpp
#if (QT_VERSION <= QT_VERSION_CHECK(5,0,0))
    ui->tableView->horizontalHeader()->setResizeMode(0, QHeaderView::Fixed);
#else
    ui->tableView->horizontalHeader()->setSectionResizeMode(0, QHeaderView::Fixed);
#endif
```
80. От Qt4 до Qt5 некоторые методы устарели или устарели. Если вы хотите включить методы Qt4 в Qt5, такие как ``setMovable QHeadVew``, вы можете добавить строку в свой файл pro или pri:``DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0``
81. QColor в Qt идеально подходит для инкапсуляции цвета и поддерживает различные преобразования, такие как rgb, hsb, cmy, hsl, соответствующие toRgb, toHsv, toCmyk, toHsl, а также поддерживает настройки прозрачности, а значение цвета также может быть преобразовано в шестнадцатеричный формат отображать.
```cpp
QColor color(255, 0, 0, 100);
qDebug() << color.name() << color.name(QColor::HexArgb);
//Вывод #ff0000 #64ff0000
```
82. Тип QVariant чрезвычайно мощный и может быть назван универсальным типом. При хранении файлов конфигурации часто используется преобразование QVariant. QVariant по умолчанию поставляется с различными преобразованиями, такими как toString и toFloat, но этого недостаточно, например , иногда нужно переключаться с QVariant на QColor, но не предоставляет функцию toColor, на этот раз нам нужно использовать универсальный метод.
```cpp
if (variant.typeName() == "QColor") {
    QColor color = variant.value<QColor>();
    QFont font = variant.value<QFont>();
    QString nodeValue = color.name(QColor::HexArgb);
}
```
83. Для преобразования между QString и const char * в Qt лучше всего использовать toStdString (). C_str () вместо toLocal8Bit (). ConstData (). Например, если вы используете последнее в setProperty, китайская строка будет неверной , и английский нормальный
84. Механизм сигнальных слотов Qt очень мощный, и он также является одной из уникальных основных функций Qt. Иногда мы передаем сигналы во многие окна для обновления или обработки. Если существует много уровней окон, например, родительский класс формы A - это Form B, родительской формой B является форма C, форма C имеет дочернюю форму D, если сигнал формы A должен быть передан в форму D, проблема возникает, вы должны сначала пройти через форму B в окно Body C, которое может затем перейдите к форме D. В этом случае будет много соединений, связанных с различными сигналами, и управление будет беспорядочным. Вы можете рассмотреть возможность добавления глобального одноэлементного класса AppEvent, поместить сюда общедоступный сигнал, а затем сформировать A, соответствующий signal привязан к AppEvent, а форма D связывает сигнал AppEvent с соответствующей функцией слота, которая является чистой и аккуратной.
85. Меню QTextEdit, вызываемое правой кнопкой мыши по умолчанию, отображается на английском языке. Если вы хотите отображать текст на китайском языке, просто загрузите файл widgets.qm. Вы можете установить несколько файлов перевода в программе Qt без конфликтов.
86. В Qt есть сигнал переключения глобального фокуса focusChanged, который можно использовать как настраиваемый метод ввода. Контекст метода ввода установлен по умолчанию в Qt4. Например, при печати a.inputContext в основной функции будет отображаться значение. Этот установленный по умолчанию контекст метода ввода будет перехватывать два замечательных сигнала QEvent :: RequestSoftwareInputPanel и QEvent :: CloseSoftwareInputPanel, так что даже если вы установите глобальный фильтр событий, эти два сигнала все равно не распознаются.Вам нужно только выполнить a.setInputContext (0) в основной функции, что означает, что контекст метода ввода установки пуст. После Qt5.7 предоставляется встроенный метод ввода, который можно включить, добавив qputenv ("QT_IM_MODULE", QByteArray ("qtvirtualkeyboard")); в начале основной функции.
87. После Qt5.10 минимальная ширина столбца по умолчанию для элемента управления таблицей QTableWidget или QTableView изменена на 15, предыдущая версия - 0, поэтому в новой версии qt, если ширина столбца таблицы установлена ​​слишком маленькой, она будет не применяется. Наименьшая ширина столбца. Поэтому, если вы хотите установить меньшую ширину столбца, вам нужно сбросить ui-> tableView-> horizontalHeader () -> setMinimumSectionSize (0);
88. Некоторые нераскрытые черные технологии, которые нельзя использовать напрямую, встроены в исходный код Qt, которые скрыты в приватном соответствующем модуле, например, частные виджеты gui-private и т. Д., Такие как класс распаковки zip-файла QZipReader и Класс сжатия QZipWriter находится в модуле gui-private In, вам нужно ввести QT + = gui-private в pro, чтобы использовать его.
```cpp
#include "QtGui/private/qzipreader_p.h"
#include "QtGui/private/qzipwriter_p.h"
ZipReader reader(dirPath);
QString path("");
//Распаковать папку в текущий каталог
reader.extractAll(path);
//Имя папки
QZipReader::FileInfo fileInfo = reader.entryInfoAt(0);
//разархивировать файлы
QFile file(filePath);
file.open(QIODevice::WriteOnly);
file.write(reader.fileData(QString::fromLocal8Bit("%1").arg(filePath)));
file.close();
reader.close();

QZipWriter *writer = new QZipWriter(dirPath);
//Добавить папку
writer->addDirectory(unCompress);
//добавить файлы
QFile file(filePath);
file.open(QIODevice::ReadOnly);
writer->addFile(data, file.readAll());
file.close();
writer->close();
```
89. Теоретически и последовательный порт, и сеть, отправляющая и получающая данные, по умолчанию являются асинхронными. Операционная система автоматически планирует и не блокирует интерфейс вообще. Те, кто в Интернете говорят, что отправляемые и получаемые данные застревают в Основной поток интерфейса - это всего несколько яиц.Реальные затраты времени связаны с вычислениями и пост-расчетной обработкой, а не с отправкой и получением данных, как правило, не рекомендуется использовать потоки для обработки в некоторых небольших проектах по вычислению данных. требуют накладных расходов на планирование. Не бросайте все в потоки. Потоки не всемогущи. Только тогда, когда действительно необходимы некоторые трудоемкие операции, такие как кодирование и декодирование, их нужно переносить в обработку потоков.

90. Получение ширины и высоты элемента управления в конструкторе, вероятно, некорректно. Правильно получать их после того, как элемент управления отображается в первый раз. Правильные значения ширины и высоты устанавливаются после того, как элемент управления отображается в первый раз. Помните, что после первого отображения, а не после запуска конструктора или программы, если некоторые элементы управления контейнера, такие как элементы управления на странице, которые не отображаются в QTabWidget после запуска программы, вы можете получить неверную ширину и высоту. • Надежный метод - получить его после первого отображения.
91. Обработка базы данных обычно рекомендуется в основном потоке. Если вам нужно сделать это в других потоках, вы должны не забыть открыть базу данных в этом потоке, то есть использовать базу данных в этом потоке, чтобы открыть ее в этом потоке. Вы не может открыть базу данных в основном потоке и выполнить sql в подпоточном потоке, очень вероятно, что возникла проблема.
92. Новая версия класса QTcpServer может не входить в функцию incomingConnection в 64-битной версии Qt. Это связано с тем, что параметр функции incomingConnection, соответствующий Qt5, был изменен. Предыдущий int был изменен на qintptr. Есть преимущество в изменении в qintptr. В 32-битной версии это автоматически quint32 в 64-битной и quint64 на 64-битной. Если параметр, который должен быть записан в Qt5, имеет значение int, проблем нет в 32-битной и 64-битной версиях, поэтому, чтобы быть совместимым с Qt4 и Qt5, он должен быть другим параметром записи.
```cpp
#if (QT_VERSION > QT_VERSION_CHECK(5,0,0))
    void incomingConnection(qintptr handle);
#else
    void incomingConnection(int handle);
#endif
```
93. Qt поддерживает все элементы управления интерфейсом, такие как QPushButton и QLineEdit, для автоматического связывания сигнального слота on_control name_signal (параметр), такого как сигнал нажатия кнопки on_pushButton_clicked (), а затем напрямую реализует функцию слота.
94. Поскольку элемент управления QWebEngineView использует opengl, на некоторых компьютерах драйвер opengl может быть слишком низким, что может вызвать мерцание экрана или различные странные проблемы. Например, правая кнопка мыши не работает в случае showfullscreen, а программный рендеринг opengl требует быть включенным в основной функции.
```cpp
#if (QT_VERSION > QT_VERSION_CHECK(5,4,0))
    //Могут использоваться следующие два метода, Qt по умолчанию использует AA_UseDesktopOpenGL
    QCoreApplication::setAttribute(Qt::AA_UseOpenGLES);
    //QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL);
#endif
    QApplication a(argc, argv);
```
Другой способ решить проблему - это то, что элемент управления полноэкранным + QWebEngineView вызовет ошибку, из-за которой контекстное меню не может появиться во всплывающем окне, и его необходимо переместить на один пиксель вверх.
```cpp
QRect rect = qApp->desktop()->geometry();
rect.setY(-1);
rect.setHeight(rect.height());
this->setGeometry(rect);
```
95. QStyle Есть много встроенных методов, которые очень полезны, например, точное получение значения ползунка, на котором нажата мышь.
```cpp
QStyle::sliderValueFromPosition(minimum(), maximum(), event->x(), width());
```
96. При использовании QFile для чтения и записи файлов рекомендуется использовать QTextStream для чтения и записи файлов. Скорость намного выше, и в основном будет улучшение на 30%. Чем больше файл, тем больше разница в производительности.
```cpp
// Загружаем из файла таблицу сравнения атрибутов на английском и китайском языках
QFile file(":/propertyname.txt");
if (file.open(QFile::ReadOnly)) {
    // Скорость чтения метода QTextStream как минимум на 30% выше
#if 0
    while(!file.atEnd()) {
        QString line = file.readLine();
        appendName(line);
    }
#else
    QTextStream in(&file);
    while (!in.atEnd()) {
        QString line = in.readLine();
        appendName(line);
    }
#endif
    file.close();
}
```
97. Использование QFile.readAll () для чтения файлов QSS по умолчанию в формате ANSI и не поддерживает UTF 8. Если вы откроете файл qss в QtCreator для редактирования и сохранения, вероятно, что qss не будет иметь никакого эффекта после загрузки.
```cpp
void frmMain::initStyle()
{
    // Загружаем таблицу стилей
    QString qss;
    //QFile file(":/qss/psblack.css");
    //QFile file(":/qss/flatwhite.css");
    QFile file(":/qss/lightblue.css");
    if (file.open(QFile::ReadOnly)) {
#if 1
        // Использование QTextStream для чтения файлов стилей не требует различения кодировки файла. Bom тоже в порядке
        QStringList list;
        QTextStream in(&file);
        //in.setCodec("utf-8");
        while (!in.atEnd()) {
            QString line;
            in >> line;
            list << line;
        }

        qss = list.join("\n");
#else
        // Использование readAll для чтения формата ANSI поддерживается по умолчанию. Если вы случайно откроете его с помощью создателя и отредактируете, возможно, вы не сможете его открыть.
        qss = QLatin1String(file.readAll());
#endif
        QString paletteColor = qss.mid(20, 7);
        qApp->setPalette(QPalette(QColor(paletteColor)));
        qApp->setStyleSheet(qss);
        file.close();
    }
}
```
98. QString имеет множество встроенных функций преобразования, например, вы можете вызвать toDouble для преобразования двойных данных, но когда вы закончите преобразование и распечатаете его, вы обнаружите, что точность меньше, и осталось только три цифры. исходные данные по-прежнему имеют полную точность, но при печати они оптимизируются до трех цифр.Если вы хотите обеспечить полную точность, вы можете вызвать функцию qSetRealNumberPrecision, чтобы установить количество цифр точности.
```cpp
QString s1, s2;
s1 = "666.5567124";
s2.setNum(888.5632123, 'f', 7);
qDebug() << qSetRealNumberPrecision(10) << s1.toDouble() << s2.toDouble();
```

99. При использовании QScriptValueIterator для анализа данных вы обнаружите, что всегда будет еще одно содержимое узла, а содержимое пустое, если вам нужно его пропустить, добавьте строку кода.
```cpp
while (it.hasNext()) {
    it.next();    
    if (it.flags() & QScriptValue::SkipInEnumeration)      
       continue;     
    qDebug() << it.name();
}
```
100. setPixmap то наихудший текстурный метод. Обычно он используется только для простых и нечастых текстур. Для рисования часто рекомендуется использовать Painter. По умолчанию используется двойная буферизация. Он отрисовывается с помощью opengl в расширенных точках и использует графический процессор.
101. Если вам нужно не перерисовывать форму при изменении размера, просто установите свойства this->setAttribute(Qt::WA_StaticContents, true); Это поможет избежать перерисовки уже отображаемой области.
102. В программе по умолчанию после получения фокуса будет виртуальная граница.Если вы посмотрите на нее и почувствуете дискомфорт, вы можете удалить ее и установить стиль.：setStyleSheet("*{outline:0px;}");
103. Некоторые часто используемые настройки элементов управления таблиц Qt инкапсулированы. QTableWidget наследуется от QTableView, поэтому следующая функция поддерживает передачу в QTableWidget.
```cpp
void QUIHelper::initTableView(QTableView *tableView, int rowHeight, bool headVisible, bool edit)
{
    //Чередование цветов в нечетных и четных рядах
    tableView->setAlternatingRowColors(false);
    //Виден ли вертикальный заголовок
    tableView->verticalHeader()->setVisible(headVisible);
    //选中一行表头是否加粗
    tableView->horizontalHeader()->setHighlightSections(false);
    //Последняя строка тянется до заполнения
    tableView->horizontalHeader()->setStretchLastSection(true);
    //Минимальная ширина заголовка строки
    tableView->horizontalHeader()->setMinimumSectionSize(0);
    //Максимальная высота заголовка строки
    tableView->horizontalHeader()->setMaximumHeight(rowHeight);
    //Высота строки по умолчанию
    tableView->verticalHeader()->setDefaultSectionSize(rowHeight);
    //Выберите строку в целом, когда она выбрана
    tableView->setSelectionBehavior(QAbstractItemView::SelectRows);
    //Разрешить выбрать только один
    tableView->setSelectionMode(QAbstractItemView::SingleSelection);

    //Заголовок не кликабельный
#if (QT_VERSION > QT_VERSION_CHECK(5,0,0))
    tableView->horizontalHeader()->setSectionsClickable(false);
#else
    tableView->horizontalHeader()->setClickable(false);
#endif

    //Нажмите мышку, чтобы войти в режим редактирования
    if (edit) {
        tableView->setEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked);
    } else {
        tableView->setEditTriggers(QAbstractItemView::NoEditTriggers);
    }
}
```
104. В некоторых крупных проектах многие подпроекты могут быть вложенными. Иногда, когда подпроекты зависят от других подпроектов, например, некоторые подпроекты используются для создания динамических библиотек, а некоторые подпроекты полагаются на эту динамическую библиотеку. для компиляции, необходимо скомпилировать подпроекты по порядку или задать правила зависимости.
```cpp
TEMPLATE = subdirs
# Установить заказанные параметры будут по очереди компилироваться в будущем projA projB projC
CONFIG  += ordered
SUBDIRS += projA
SUBDIRS += projB
SUBDIRS += projC
# Вы также можете указать зависимость проекта, установив зависимости. Например, укажите projB, чтобы он зависел от projA ниже
projB.depends = projA
projC.depends = projA
projD.depends = projC
```
105. Инструкции по выбору компилятора MSVC
- Если это 32-битный Qt, компилятор выбирает начало x86
- Если это 64-битный Qt, компилятор выбирает начало amd64
- В частности, это зависит от установленной версии комплекта сборки Qt, разрядности системы и архитектуры целевой операционной платформы.
- Как правило, современные компьютеры по умолчанию в основном 64-битные, просто выберите amd64.
- Если пользователю нужна 32-битная совместимая система, рекомендуется выбрать 32-битную Qt, чтобы она могла работать в 32-битных или 64-битных системах.
- Г-н Чжугэ добавил: x86 / x64 компилируются и запускаются в одной среде, и нет или. Подчеркнутый - это кросс-компиляция, спереди - среда компиляции, а сзади - среда выполнения.

| Имя | Описание  |
| ------ | ------ |
|x86|32/64 Составлено на 32/64 Беги на битовой системе|
|x86_amd64|32/64位系统上编译在64位系统上运行|
|x86_arm|32/64位系统上编译在arm系统上运行|
|amd64|64位系统上编译在64位系统上运行|
|amd64_x86|64位系统上编译在32/64位系统上运行|
|amd64_arm|64位系统上编译在arm系统上运行|

106. Много раз при использовании QDialog вы обнаруживаете, что сообщение заблокировано, и иногда мы надеемся, что некоторые сообщения в фоновом режиме будут продолжать работать и не будут завершены. В настоящее время нам необходимо выполнить настройку.
```cpp
QDialog dialog;
dialog.setWindowModality(Qt::WindowModal);
```
107. Многие новички или даже люди с многолетним опытом работы глубоко не понимают и злоупотребляют многопоточностью, особенно в последовательном порте и сетевом взаимодействии, все бросается в многопоточность. Как только интерфейсная карта встречается, данные будут быть отправленным и полученным. Все делается в многопоточном режиме, но в большинстве случаев это совершенно бесполезно, потому что не обнаружена первопричина проблемы.
- Если вы не используете функцию `` wait *** '', большая часть интерфейсных карт находится в процессе обработки и отображения данных. Это должно занять много времени;
- Существует также кривая полученных данных. Если они слишком частые или интервал слишком короткий, это определенно вызовет сильную нагрузку на пользовательский интерфейс. Лучший способ - решить, как не рисовать пользовательский интерфейс часто, например объединение объединенных данных воедино;
- Если карта вызвана отрисовкой пользовательского интерфейса, то многопоточность бесполезна, поскольку пользовательский интерфейс может находиться только в основном потоке;
- Передача и прием данных через последовательный порт и сеть по умолчанию асинхронны и планируются операционной системой. Если обработка данных сложная и объем данных велик, вам нужно выполнить обработку данных в нескольких потоки;
- Если нет строгих требований к синхронизации данных, нет необходимости вызывать такие функции, как wait *** для немедленной отправки и получения данных.В реальных требованиях большинства сценариев приложений на самом деле достаточно, чтобы отправлять и получать данные асинхронно;
- В сценариях со строгими требованиями к синхронизации данных лучше размещать несколько потоков, иначе ваше ``wait ***`` застрянет там;
- Многопоточность должна занимать системные ресурсы. Теоретически, если количество потоков превышает количество ядер ЦП, на самом деле многопоточное планирование может занять больше времени. Вы должны взвесить все «за» и «против» во время использования;
- Опять же, не ожидайте, что сетевое взаимодействие Qt будет поддерживать высокий уровень параллелизма. До 1000 может работать нормально, и все будет хорошо. Как правило, рекомендуется количество подключений в пределах 500. Для большого количества требований с высоким уровнем параллелизма используйте сторонние библиотеки, такие как swoole.

108. Во встроенном Linux, если установлено окно без полей и в нем есть текстовое поле, обнаруживается, что фокус не может быть сгенерирован для ввода, и окно должно быть активно активировано в это время.
```cpp
//Установленное таким образом окно без полей не может фокусироваться на встроенных устройствах.
setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint);

//Необходимо активировать форму после показа
w->show();
w->activateWindow();
```
109. QString из replace Функция изменит исходную строку. Помните, она также изменит исходную строку при возврате замененной новой строки, моя дорогая!
110. Связанные эффекты класса QGraphicsEffect очень ошеломляющие и могут достигать многих эффектов, таких как прозрачность, градиенты, тени и т. Д., Но этот класс очень загружает процессор, и обычно не рекомендуется использовать его, если он не особенно необходим. 
111. Косая черта в пути к файлу отличается на разных платформах. Например, в Linux-системах обычно используется /, но в Windows это \\ две обратные косые черты. Сама программа Qt поддерживает как win, так и linux. / Путь косой черты, но некоторые сторонние библиотеки могут нуждаться в преобразовании в путь соответствующей системы, что требует использования преобразования косой черты.Конечно, Qt имеет встроенные методы класса.
```cpp
QString path = "C:/temp/test.txt";
path = QDir::toNativeSeparators(path);
//Вывод C:\\temp\\test.txt

QString path = "C:\\temp\\test.txt";
path = QDir::toNativeSeparators(path);
//Вывод C:/temp/test.txt
```
112. Умное использование QMetaObject::invokeMethod Метод позволяет достичь многих эффектов, включая синхронное и асинхронное выполнение, в значительной степени решить проблему межпотоковой обработки сигнальных слотов. Например, в обратном вызове есть сценарий приложения, который нужно вызывать асинхронно. publicФункция, если она вызывается напрямую, будет признана неудачной. В это время вам нужно использовать QMetaObject::invokeMethod(obj, "fun", Qt::QueuedConnection); Просто иди этим путем.
- invokeMethod Функция имеет много перегруженных параметров, вы можете передать возвращаемое значение и параметры метода выполнения.
- invokeMethod Функция не только поддерживает функции слотов, но также поддерживает сигналы, и на самом деле это потокобезопасно, и ее можно с уверенностью использовать в потоках, здорово!
- Тест показал, что могут быть выполнены только методы, идентифицированные сигналами или слотами.
- По умолчанию функции из частных (защищенных / общедоступных) слотов могут выполняться, но функции из частных (защищенных / общедоступных) не могут выполняться.
-Г-н Мао добавил: Предпосылка должна быть функцией, отмеченной слотами или сигналами. Незаметная функция отсутствует в метаинформации и не может быть найдена. После выполнения будет предложено Нет такого метода.
- 2021-11-06Дополнение: если вы хотите выполнить функцию под приватным (защищенным / общедоступным), вам нужно добавить ключевое слово Q_INVOKABLE перед функцией.Я снова выучил его сегодня и должен добавить куриные окорочка.
- Фактически, если посмотреть на это с этой точки зрения, может быть выполнена любая функция метода, которая выходит за пределы частного (защищенного / общедоступного). Это эквивалентно тому, что частная функция класса может быть выполнена с помощью invokeMethod, если она изменена с помощью ключевое слово Q_INVOKABLE. Щелкните.
```cpp
//Заголовочный файл объявляет функции сигналов и слотов.
signals:
    void sig_test(int type,double value);
private slots:
    void slot_test(int type, double value);
private:
    Q_INVOKABLE void fun_test(int type, double value);

//Слот сигнала, связанный с конструктором
connect(this, SIGNAL(sig_test(int, double)), this, SLOT(slot_test(int, double)));

//Нажмите кнопку, чтобы запустить сигнал и слот, вот пример сигнального слота одновременно
void MainWindow::on_pushButton_clicked()
{
    QMetaObject::invokeMethod(this, "sig_test", Q_ARG(int, 66), Q_ARG(double, 66.66));
    QMetaObject::invokeMethod(this, "slot_test", Q_ARG(int, 88), Q_ARG(double, 88.88));
    QMetaObject::invokeMethod(this, "fun_test", Q_ARG(int, 99), Q_ARG(double, 99.99));
}

//Напечатаю 66 66.66、88 88.88
void MainWindow::slot_test(int type, double value)
{
    qDebug() << type << value;
}

//Напечатаю 99.99
void MainWindow::fun_test(int type, double value)
{
    qDebug() << type << value;
}
```
