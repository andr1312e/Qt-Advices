feiyangqingyun /qtkaifajingyan

1. Когда в компиляции обнаруживается большое количество ошибок, начните с первой и устраняйте их одну за другой. Не спешите увидеть следующую ошибку. Часто последние ошибки вызваны предыдущими ошибками. Могут быть все решено
2. Таймер - хорошая вещь, научитесь его использовать, иногда с помощью одиночного таймера QTimer :: singleShot и QMetaObject :: invokeMethod можно решить неожиданные проблемы. Например, загрузка занимает много времени при инициализации формы, поэтому легко застрять на главном дисплее интерфейса, и интерфейс не будет отображаться до завершения загрузки, что приводит к очень неприятным ощущениям. Загрузка времени (иногда эти загрузки должны выполняться в основном потоке, например, при использовании окна стека QStackWidget для загрузки некоторых подформ), отложенная или асинхронная загрузка, чтобы она выполнялась после отображения интерфейса вместо основного основного интерфейса.
```cpp
//Выполнять функцию загрузки асинхронно
QMetaObject::invokeMethod(this, "load", Qt::QueuedConnection);
//Задержка 10 миллисекунд для выполнения функции загрузки
QTimer::singleShot(10, this, SLOT(load()));
```
3.QtCreator по умолчанию - это однопоточная компиляция. В начале проектирования можно подумать, что он не занимает как можно больше системных ресурсов. В настоящее время компьютеры являются многоядерными. Компилятор msvc по умолчанию - это многопоточная компиляция без ручной настройки. другие компиляторы, вам нужно установить его вручную.
- Метод 1. На этапе сборки параметров сборки каждого проекта (вы можете проверить страницу теневой сборки) добавьте строку -j16 для создания аргументов. Этот параметр будет сохранен в файле pro.user и понадобится, когда он удален Reset, этот метод не рекомендуется;
- Метод 2: Добавьте в среду комплекта сборки, Инструменты-> Параметры-> Комплекты сборки-> Выберите комплект сборки-> среда-> кнопка изменения справа-> Введите MAKEFLAGS = -j4 в открытое поле ввода, В таким образом, вам не нужно каждый раз настраивать многопоточную компиляцию, пока это проект, который использует этот набор компонентов, этот параметр компиляции будет добавлен; 
- Примечание: за -j следует количество ядер компьютера. Если вы напишете слишком много, не будет никакого эффекта. Вы должны проверить параметры компьютера или ввести -j4. Ведь 4 ядра компьютер должен быть самым основным; 
- Вероятно, новая версия QtCreator, начиная с 2019 года, будет автоматически устанавливать многопоточную компиляцию в соответствии с ядром компьютера по умолчанию. Например, если он распознает, что ваш компьютер 16-ядерный, он будет компилироваться с параметром -j16 по умолчанию ; 

4. Если вы хотите использовать QtCreator для беспрепятственного развертывания программ Android, вы должны сначала успешно настроить его в AndroidStudio, чтобы сгладить все неровности. 

5. Много раз после нахождения соответствующего метода инкапсуляции Qt не забывайте больше смотреть на перегрузку функции. Если у вас несколько параметров, вы найдете другой мир, и иногда вы внезапно поймете, что Qt уже инкапсулировал его для us, например, перегруженные параметры QString и QColor чрезвычайно богаты.

6. Вы можете записать номер версии метки + значок ico в файл pro (поддерживается только Qt5) .На самом деле, когда это qmake в Windows, эта информация будет автоматически преобразована в файл rc. 

```cpp
VERSION  = 2025.10.01
RC_ICONS = main.ico
```

7. Администратор запускает программу, ограниченную компилятором MSVC. 
```cpp
QMAKE_LFLAGS += /MANIFESTUAC:"level='requireAdministrator' uiAccess='false'" #Запустить от имени администратора
QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,"5.01" # VS2013 Запуск на XP
```
8. В рабочем файле есть окно вывода отладки. Это очень полезно. Много раз, когда мы выпускаем программу, мы сталкиваемся с тем, что программа дважды щелкает и не запускается без сообщения об ошибке (на машине разработки все в норме. ), и мы не знаем, что произошло, или даже о задаче. Менеджер видит, что она запущена, но интерфейс не появляется. В это время вам нужно добавить это в файл pro проекта. Программа с интерфейсом также автоматически откроет окно отладки, чтобы распечатать информацию, которая удобна для поиска проблем. Как правило, он не может работать нормально. Программа будет печатать некоторые подсказки и так далее. 
```cpp
TEMPLATE    = app
MOC_DIR     = temp/moc
RCC_DIR     = temp/rcc
UI_DIR      = temp/ui
OBJECTS_DIR = temp/obj
# Следующая строка используется для установки рабочего файла с окном вывода отладки 
CONFIG      += console
```
9. Нарисуйте мозаичный фон QPainter :: drawTiledPixmap и нарисуйте прямоугольник с закругленными углами QPainter :: drawRoundedRect () вместо QPainter :: drawRoundRect (); 
10. Удалить старый стиль 
```cpp
//Удалить исходный стиль 
style()->unpolish(ui->btn);
//Должна быть следующая строка, иначе он не будет удален 
ui->btn->setStyleSheet("");
//Сбросьте новый стиль элемента управления.
style()->polish(ui->btn);
```

11.Получить атрибуты класса
```cpp
const QMetaObject *metaobject = object->metaObject();
int count = metaobject->propertyCount();
for (int i = 0; i < count; ++i) {
    QMetaProperty metaproperty = metaobject->property(i);
    const char *name = metaproperty.name();
    QVariant value = object->property(name);
    qDebug() << name << value;
}
```

12. Встроенные значки Qt инкапсулированы в QStyle, и существует около 70 значков, которые можно использовать напрямую. 
```cpp
SP_TitleBarMenuButton,
SP_TitleBarMinButton,
SP_TitleBarMaxButton,
SP_TitleBarCloseButton,
SP_MessageBoxInformation,
SP_MessageBoxWarning,
SP_MessageBoxCritical,
SP_MessageBoxQuestion,
...
//Просто вытащите его и используйте вот так

QPixmap pixmap = this->style()->standardPixmap(QStyle::SP_TitleBarMenuButton);
ui->label->setPixmap(pixmap);

```
13. Оценивайте загрузку по количеству битов операционной системы.
```cpp
win32 {
    contains(DEFINES, WIN64) {
        DESTDIR = $$PWD/../bin64
    } else { 
        DESTDIR = $$PWD/../bin32
    }
}
```

14. Qt5 значительно улучшил проверку безопасности.Если появляется setGeometry: Unable to set geometry, переместите видимость элемента управления после добавления его в макет. 
15. Вы можете добавить элемент управления A в макет, а затем элемент управления B, чтобы задать макет. Такая гибкость улучшает комбинацию элементов управления. Например, вы можете добавить кнопку поиска слева и справа от текстового поля, а кнопку можно установить значок.
```cpp
QPushButton *btn = new QPushButton;
btn->resize(30, ui->lineEdit->height());
QHBoxLayout *layout = new QHBoxLayout(ui->lineEdit);
layout->setMargin(0);
layout->addStretch();
layout->addWidget(btn);
```

16. Чтобы установить стиль элемента управления QLCDNumber, вам необходимо установить стиль сегмента QLCDNumber на плоский, иначе вы не обнаружите никакого эффекта.

17. Умное использование findChildren позволяет находить все дочерние элементы управления под элементом управления. findChild - найти сингл.
```cpp
//Найдите элемент управления с указанным именем класса objectName
QList<QWidget *> widgets = fatherWidget.findChildren<QWidget *>("widgetname");

//Найти все QPushButton
QList<QPushButton *> allPButtons = fatherWidget.findChildren<QPushButton *>();

//Найдите подэлемент управления первого уровня, иначе он всегда будет проходить через все подэлементы управления.
QList<QPushButton *> childButtons = fatherWidget.findChildren<QPushButton *>(QString(), Qt::FindDirectChildrenOnly);

```
18. Используйте наследование с умом, чтобы определить, принадлежит ли оно к определенной категории.
`` cpp
QTimer * timer = new QTimer; // QTimer наследует QObject

timer-> inherits ("QTimer"); // возвращает истину

timer-> inherits ("QObject"); // возвращает истину

timer-> inherits ("QAbstractButton"); // возвращает false
`` '' 

19. Используя механизм слабых атрибутов, временные значения могут быть сохранены для принятия решения о передаче. Вы можете перечислить все имена слабых свойств с помощью widget-> dynamicPropertyNames (), а затем получить значение соответствующего слабого свойства с помощью widget-> property ("name"). 
20. Во время разработки, будь то для удобства обслуживания или из соображений экономии ресурсов памяти, должен быть файл qss для хранения всех таблиц стилей, а setStyleSheet не следует писать везде. Если это начальный этап или этап тестирования, вы можете щелкнуть правой кнопкой мыши пользовательский интерфейс, чтобы установить таблицу стилей.Для формальных проектов лучше объединить файл таблицы стилей в файл таблицы стилей qss для унифицированного управления. 
21. Если появляется сообщение об ошибке Z-order_assignment: is_not_a_valid_widget., Откройте соответствующий файл пользовательского интерфейса с помощью Блокнота, найдите место, где <zorder> </zorder> пуст, и удалите его.
22. Уметь использовать второй параметр addItem ComboBox для установки пользовательских данных, которые могут дать множество эффектов, и использовать _itemData, чтобы получить их.
23.  Если используется модуль webengine, принесите QtWebEngineProcess.exe + папку переводов + папку ресурсов при публикации программы. 
24.  По умолчанию Qt является дескриптором окна.Если вы хотите, чтобы каждый элемент управления имел независимый дескриптор, установите a.setAttribute (Qt :: AA_NativeWindows); 
25.  Qt + Android предотвращает закрытие программы. 
```cpp
#if defined(Q_OS_ANDROID)
QAndroidService a(argc, argv);
return a.exec()
#else
QApplication a(argc, argv);
return a.exec();
#endif
```
26. Вы можете установить стиль общего индикатора вместо индивидуальной настройки индикатора для каждого элемента управления.
```cpp
*::down-arrow{}
*::menu-indicator{}
*::up-arrow:disabled{}
*::up-arrow:off{}
```
27. Вы можете установить фоновое изображение в указанном месте. 
```cpp
QMainWindow > .QWidget {
    background-color: gainsboro;
    background-image: url(:/images/pagefold.png);
    background-position: top right;
    background-repeat: no-repeat
}
```
28. Встроенный Linux, работающий с программой Qt 
```cpp
//Написание Qt4
./HelloQt -qws &

//Формулировка Qt5 xcb может быть изменена на linuxfb eglfs vnc wayland и т. Д., Используйте то, что нужно для тестирования, по очереди
./HelloQt --platform xcb
./HelloQt --platform wayland
```
29. Файл конфигурации программного обеспечения Qtcreator хранится по адресу: C: \ Users \ Administrator \ AppData \ Roaming \ QtProject. Иногда, если что-то пойдет не так, удалите эту папку и откройте создатель, чтобы автоматически восстановить ее. 
30. QMediaPlayer - это оболочка (также может называться фреймворком), использующая локальный декодер, видео в основном воспроизводит MP4 по умолчанию, и даже MP4 не может быть воспроизведен. Если вы хотите поддерживать другие форматы, вам необходимо загрузить k -lite или LAV Filters и установите его. (K-lite или LAV Filters относятся к окнам, ищите в других системах самостоятельно, похоже, что встроенный linux полагается на GStreamer, который не был полностью проверен). Если вам нужен мощный проигрыватель, новички рекомендуют использовать vlc, mpv и окончательный универсальный метод с использованием ffmpeg (декодированное видео можно нарисовать с помощью QOpenGLWidget с помощью графического процессора или преобразовать в QImage для рисования, а аудиоданные можно воспроизвести с помощью QAudioOutput).
31. Определите тип компилятора, версию компилятора и операционную систему.
```cpp
//Компилятор GCC
#ifdef __GNUC__
#if __GNUC__ >= 3   // GCC3.0  выше

//Компилятор MSVC
#ifdef _MSC_VER
#if _MSC_VER >=1000 // VC++4.0 выше
#if _MSC_VER >=1100 // VC++5.0 выше
#if _MSC_VER >=1200 // VC++6.0 выше
#if _MSC_VER >=1300 // VC2003  выше
#if _MSC_VER >=1400 // VC2005  выше
#if _MSC_VER >=1500 // VC2008  выше
#if _MSC_VER >=1600 // VC2010  выше
#if _MSC_VER >=1700 // VC2012  выше
#if _MSC_VER >=1800 // VC2013  выше
#if _MSC_VER >=1900 // VC2015  выше

//Borland C++
#ifdef __BORLANDC__

//Cygwin
#ifdef __CYGWIN__
#ifdef __CYGWIN32__

//mingw
#ifdef __MINGW32__

//windows
#ifdef _WIN32           //32bit
#ifdef _WIN64           //64bit
#ifdef _WINDOWS         //Программа с графическим интерфейсом
#ifdef _CONSOLE         //Консольная программа

//Windows（95/98/Me/NT/2000/XP/Vista）И Windows CE определила
#if (WINVER >= 0x030a)  // Windows 3.1 выше
#if (WINVER >= 0x0400)  // Windows 95/NT4.0 выше
#if (WINVER >= 0x0410)  // Windows 98 выше
#if (WINVER >= 0x0500)  // Windows Me/2000 выше
#if (WINVER >= 0x0501)  // Windows XP выше
#if (WINVER >= 0x0600)  // Windows Vista выше

//_WIN32_WINNT версия ядра
#if (_WIN32_WINNT >= 0x0500) // Windows 2000 выше
#if (_WIN32_WINNT >= 0x0501) // Windows XP выше
#if (_WIN32_WINNT >= 0x0600) // Windows Vista выше

```

32. Определите версию Qt и количество пакетов сборки в pro 
```cpp
# Распечатать информацию о версии
message(qt version: $$QT_VERSION)
# Оценка текущего номера версии qt
QT_VERSION = $$[QT_VERSION]
QT_VERSION = $$split(QT_VERSION, ".")
QT_VER_MAJ = $$member(QT_VERSION, 0)
QT_VER_MIN = $$member(QT_VERSION, 1)
# Следующее для Qt5.5 и выше
greaterThan(QT_VER_MAJ, 4) {
greaterThan(QT_VER_MIN, 4) {
# Выполните некоторую обработку в соответствии с вашими потребностями
}}

#QT_ARCH является новым в Qt5 и не влияет на Qt4
# Распечатать информацию о текущем комплекте сборки Qt
message($$QT_ARCH)
# Указывает комплект сборки платформы _arm
contains(QT_ARCH, arm) {}
# Указывает на 32-битный комплект сборки
contains(QT_ARCH, i386) {}
# Указывает на 64-битный комплект сборки
contains(QT_ARCH, x86_64) {}

# Фактически, Qt имеет встроенные переменные номера основной версии и номера подверсии
# Оценка текущего номера версии qt
message($$QT_ARCH : $$QT_VERSION -> $$QT_MAJOR_VERSION . $$QT_MINOR_VERSION)

# Значение ниже, если версия <4.8
lessThan(QT_MAJOR_VERSION, 5) {
lessThan(QT_MINOR_VERSION, 8) {
# Здесь нужно выполнить обработку
}}

# Значение ниже, если версия> = 5.5
greaterThan(QT_MAJOR_VERSION, 4) {
greaterThan(QT_MINOR_VERSION, 4) {
# Здесь нужно выполнить обработку
}}

// Не судите версию в коде слишком просто
#if (QT_VERSION >= QT_VERSION_CHECK(6,0,0))
// Вот что делать
#endif
```

33. После сворачивания Qt интерфейс будет восстановлен до зависания и зависания, плюс код
```cpp
void showEvent(QShowEvent *e)
{
    setAttribute(Qt::WA_Mapped);
    QWidget::showEvent(e);
}
```
34. Получите высоту строки заголовка: style () -> pixelMetric (QStyle :: PM TitleBarHeight); Щелкните PM TitleBarHeight, и вы найдете новый мир.
35. Установите свойства экрана с высоким разрешением для поддержки высоких разрешений, таких как 2K4K, особенно для мобильных телефонов. app。Должен быть написан на main   Функциональный QApplication a(argc, argv);Спереди.
```cpp
#if (QT_VERSION > QT_VERSION_CHECK(5,6,0))
    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
#endif
    QApplication a(argc, argv);
```
36. Если запущенная программа появляется Fault tolerant heap shim applied to current process. This is usually due to previous crashes.Ошибка。
- Шаг 1: введите команду regedit Откройте реестр；
- Шаг 2: Найдите узел HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers\；
- Шаг 3: выберите Layers Ключ-значение, удалите собственный путь к программе из списка справа.
37. Встроенная в Qt компоновка формы QFormLayout используется для автоматической генерации интерфейса формы комбинации метки + поля ввода. Она редко используется для установки компоновки, и наиболее часто используются горизонтальная компоновка, вертикальная компоновка и компоновка таблицы. .
38. Qml для воспроизведения видео необходимо установить в Linux sudo apt-get install libpulse-dev.
39. Вы можете напрямую наследовать QSqlQueryModel для реализации пользовательской модели QueryModel, такой как цвет шрифта столбца, заполнитель, другие стили и т. Д., И переписать QVariant CustomSqlModel :: data (const QModelIndex & index, int role) const.
40. После Qt5 предоставляется класс QScroller для прямой прокрутки элемента управления.
```cpp
//Отключить горизонтальную полосу прокрутки
ui->listWidget->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//Отключить вертикальную полосу прокрутки
ui->listWidget->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//Установите горизонтальную прокрутку в соответствии со значением пикселя
ui->listWidget->setHorizontalScrollMode(QListWidget::ScrollPerPixel);
//Установите вертикальную прокрутку в соответствии со значением пикселя
ui->listWidget->setVerticalScrollMode(QListWidget::ScrollPerPixel);
//Установите объект прокрутки и метод прокрутки для прокрутки левой кнопкой мыши
QScroller::grabGesture(ui->listWidget, QScroller::LeftMouseButtonGesture);
//Также есть QScrollerProperties, который может устанавливать некоторые параметры прокрутки.
```

41. Если вы не хотите создавать файл базы данных при использовании базы данных sqlite, вы можете создать базу данных в памяти.
```cpp
QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE");
db.setDatabaseName(":memory:");
```
42. Очистите таблицу данных и сбросьте самоинкремент ID，sql = truncate table table_name。

43. Qtchart Модуль от Qt5.7 Он идет вместе с ним, а минимальная компиляция требует Qt5.4. Не забудьте проверить это во время установки, по умолчанию он не отмечен. Использование этого модуля требует введения пространства имен.
```cpp
#include <QChartView>
QT_CHARTS_USE_NAMESPACE
class CustomChart : public QChartView
```
44. QPushButton Текст с выравниванием по левому краю, необходимо установить таблицу стилей QPushButton{text-align:left;}

45. QLabel Есть три способа установить текст, освоить систему атрибутов Qt и сделать выводы друг из друга, вы можете добиться множества эффектов.
```cpp
//Традиционный подход
ui->label->setText("hello");
//Трюки
ui->label->setProperty("text", "hello");
//Атрибут Дафа
ui->label->setStyleSheet("qproperty-text:hello;");
```
46. Умное использование QEventLoop Включение цикла обработки событий может привести к синхронному извлечению и возврату результатов без блокировки интерфейса. Проверьте исходный код, оказывается QEventLoop Выполнение потока создается заново внутри.
```cpp
QEventLoop loop;
connect(reply, SIGNAL(finished()), &loop, SLOT(quit()));
loop.exec();
```

47. Несколько предопределенных переменных #if (defined webkit) || (defined webengine)，Удалите сгенерированный пустой debug и release содержание CONFIG -= debug_and_release。

48. Новая версия Qtcreator Расширенная проверка грамматики, появится много предупреждений и т. Д., Можно закрыть в списке плагинов clang Только первые несколько ，Help》About Plugins。Вы также можете установить уровень проверки кода，Tools》Options 》C++ 》Code Model。
49. QSqlTableModel из rowCount Метод, максимальная доходность по умолчанию 256，Если он превышает 256，Вы можете потянуть стол вниз, он автоматически загрузит оставшиеся, каждый раз самая большая загрузка 256 Данные панели. Если вам нужно распечатать или экспортировать данные, помните, что лучше всего использовать sql Заявление для просмотра вместо использования QSqlTableModel из rowCount метод. В противном случае это всегда будет самый крупный и единственный экспорт. 256 Данные статьи.
Если объем данных невелик, можно также использовать следующие методы:
```cpp
//Активно загружать все данные, иначе количество строк получится<=256
while(model->canFetchMore()) {
    model->fetchMore();
}
```

50. Если вам нужно указать окно без полей, но вам нужно сохранить характеристики границ операционной системы, вы можете свободно растянуть границу, вы можете использовать setWindowFlags(Qt::CustomizeWindowHint);
51. В некоторых http post При отправке данных, если вы используете для отправки данные соединения _string, если китайский язык анализирует искаженные символы, вам необходимо перекодировать китайский URL.
```cpp
QString content = "测试中文";
QString note = content.toUtf8().toPercentEncoding();
```

52. Qt По умолчанию большие файлы ресурсов не поддерживаются. Например, если добавляются файлы шрифтов, вам потребуется pro Файл открыт。
CONFIG += resources_big


53. После наследования QWidget в Qt таблица стилей не работает.Есть три решения. Настоятельно рекомендуется первый метод.
- Метод 1: установить атрибут this-> setAttribute (Qt :: WA_StyledBackground, true);
- Метод 2: изменить наследование QFrame, потому что QFrame имеет свою собственную функцию paintEvent, которая была реализована, и она будет проанализирована и отрисована при использовании таблицы стилей.
- Метод 3: при повторной реализации функции paintEvent QWidget использовать для рисования QStylePainter. 
```cpp
void Widget::paintEvent(QPaintEvent *)
{
    QStyleOption option;
    option.initFrom(this);
    QPainter painter(this);
    style()->drawPrimitive(QStyle::PE_Widget, &option, &painter, this);
}
```

54. Иногда к интерфейсу добавляется пружина, и стратегию растяжения, соответствующую пружине, необходимо динамически изменять. Соответствующий метод - changeSize，Многие люди предпочтут использовать set Я нашел это в начале, я не мог найти。
55. В процессе использования QFile не рекомендуется часто открывать файл для записи, а затем закрывать файл. Например, выводить журнал каждые 5 мсек. Узкое место производительности ввода-вывода очень велико. В этом случае рекомендуется открывать файл сначала и не закрывайте его, и дождитесь подходящего времени, такого как деструктор.Закройте файл, когда файл журнала необходимо снова изменить, когда изменилась дата. В противном случае открытие и закрытие большого количества файлов за короткий промежуток времени будет очень зависнуть, чем больше файл, тем больше зависает.
56. Во многих сетевых приложениях для поддержания соединения требуется настраиваемый контрольный пакет. В противном случае отключится питание или программа будет незаконно закрыта, и другая сторона не сможет ее распознать. Требуется обнаружение тайм-аута. Однако некоторые программы не обеспечивают протокол подтверждения. В настоящее время необходимо включить поддержку активности на уровне системы. Процедура, этот метод подходит для TCP-соединения.
```cpp
int fd = tcpSocket->socketDescriptor();
int keepAlive = 1;      //Включить атрибут keepalive, значение по умолчанию: 0 (закрыто)
int keepIdle = 5;       //Если нет взаимодействия с данными в течение 5 секунд, обнаружение будет выполнено, значение по умолчанию: 7200 (с)
int keepInterval = 2;   //Интервал времени для отправки пакетов обнаружения во время обнаружения составляет 2 секунды, значение по умолчанию: 75 (с).
int keepCount = 2;      //Количество повторных попыток обнаружения, если все таймауты, соединение считается недействительным, значение по умолчанию: 9 (раз)
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&keepAlive, sizeof(keepAlive));
setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, (void *)&keepIdle, sizeof(keepIdle));
setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, (void *)&keepInterval, sizeof(keepInterval));
setsockopt(fd, SOL_TCP, TCP_KEEPCNT, (void *)&keepCount, sizeof(keepCount));
```
57. Если программа упакована, появится всплывающее окно This application failed to start because it could not find or load the Qt platform plugin 一Обычно это вызвано тем, что каталог плагинов платформы не упакован или упакован неправильно.


58. Не рекомендуется включать китайский язык в tr. Хотя новая версия Qt поддерживает перевод с китайского на другие языки, он не стандартизирован, и я не знаю, кто преподавал TMD. Первоначальное значение tr - включить английский, а затем перевести его на другие языки, такие как китайский. В настоящее время большое количество новичков злоупотребляют tr. Если нет необходимости в переводе, tr отключен, а tr требует накладных расходов. По умолчанию Qt будет думать, что ему нужен перевод, и выполнит дополнительная специальная обработка.
59. Многие люди глупо не знают разницы между Qt и Qt Creator. Они часто спрашивают, какая версия Qt и результат - версия Qt Creator. Qt Creator - это интегрированная среда разработки IDE, написанная Qt. вселенная, это может быть компилятор msvc (Qt Cerator, который поставляется с интегрированной установочной средой Qt, соответствующей WIN, - это msvc), он также может быть скомпилирован с помощью mingw или gcc. Если это подключаемый модуль настраиваемого элемента управления, он должен быть интегрирован в Qt Creator, а компилятор, соответствующий файлу динамической библиотеки (файл dll или другой) подключаемого модуля, должен быть точно таким же, как версия Qt и версия количество бит и версию Qt Creator, иначе вряд ли он будет интегрирован. Особое внимание уделяется версии Qt в установочном пакете интегрированной среды Qt, и версия Qt Creator может быть не совсем такой же, вы должны держать глаза открытыми, чтобы ясно видеть, некоторые из них точно такие же.
60. Рекомендуется писать отдельные функции для более чем двух одинаковых кодов обработки. Код должен быть как можно более стандартным и кратким. Например, ``if (a == 123)`` нужно записать как ``if (123 == a)`` со значением впереди и, например, ``if (ok == true)`` следует писать как ``if (ok)`` ,``if (ok == false)``следует писать как`` if (! ok) ``и т. д.
61. Многие люди спрашивают, какая встроенная платформа Qt лучше, и вот единый ответ (текущий узел времени 2018): imx6 + 335x относительно стабилен, высокая производительность, используйте RK3288 RK3399, если это дешево, используйте Allwinner H3, поиграйте с Raspberry Pie апельсиновый пирог.
62. Для большого фрагмента кода комментария рекомендуется использовать #if 0 #endif, чтобы включить блок кода, вместо того, чтобы выбирать код и комментировать все его двойными косыми чертами. Если вы хотите открыть этот код в следующий раз, вам нужно повторно выбрать его и отмените снова. Если вы используете #if 0, вам нужно только изменить 0 на 1, что значительно повысит эффективность разработки.
63. Есть много способов упаковать и выпустить Qt. После Qt5 он предоставляет упаковочный инструмент windeployqt (linuxdeployqt в Linux, macdeployqt в Mac), который может быть очень удобным для упаковки приложений. После его использования он не всемогущ. больше пакетов.Зависимые файлы, иногда вы забываете упаковать некоторые плагины, особенно когда используется qml, и сторонние библиотеки не могут быть распознаны.Например, если программа зависит от ffmpeg, соответствующую библиотеку нужно скопировать самостоятельно . Самый лучший метод - скопировать исполняемый файл. Скопировать его в каталог bin в каталоге установки Qt, а затем упаковать весь пакет вместе и удалить компоненты, которые вряд ли будут зависеть от одного за другим, пока нормальная операция не будет удалена. .
64. Анимация в Qt, нижний уровень использует таймер QElapsedTimer для завершения обработки, такой как генерация некоторых данных определенного алгоритма правила, а затем обработка атрибутов.
65. При рисовании круга без цвета фона и только с цветом границы вы можете заменить его дугой на 360 градусов, и эффект будет точно таким же.
```cpp
QRect rect(-radius, -radius, radius * 2, radius * 2);
//Выберите один из следующих двух методов. На самом деле, рисование дуги на 360 градусов = рисование круга без фона.
painter->drawArc(rect, 0, 360 * 16);
painter->drawEllipse(rect);
```
66. Не смотрите на указатель d очень загадочно. Фактически, частный класс определен в файле реализации класса для хранения локальных переменных. Я лично считаю, что при выполнении некоторых небольших проектов нет особой необходимости вводить этот механизм , что снизит производительность кода.Читаемость увеличивает сложность, и новички будут сбиты с толку после принятия проекта.
67. Когда многие люди рисуют, настраивая кисть, они думают, что могут установить только монотонный цвет. Фактически, QPen также может настраивать кисть, поэтому гибкость увеличивается во много раз. Например, после настройки кисти QPen, вы можете использовать различные градиенты, например, рисовать индикаторы выполнения и текст в градиентных цветах вместо монотонного цвета.
68. Многие элементы управления имеют область просмотра, например QTextEdit / QTableWidget / QScrollArea. Иногда, когда эти элементы управления обрабатываются напрямую, обнаруживается, что это не работает. Вам необходимо установить viewport (). Например, чтобы установить фон прокрутки Чтобы область полосы была прозрачной, вам необходимо использовать scrollArea-> viewport () -> setStyleSheet ("background-color: transparent;"); вместо scrollArea-> setStyleSheet ("QScrollArea {background-color: transparent;}");
69. Иногда для setMouseTracking отслеживания мыши задано значение true. Если в форме есть другие элементы управления, когда мышь перемещается к другим элементам управления, родительское событие движения мыши MouseMove не может быть распознано. В это время необходимо событие HoverMove. Сначала установите setAttribute (Qt :: WA_Hover, истина);
70. Класс даты и времени QDateTime, инкапсулированный в Qt, очень мощный: он может преобразовывать строки символов и дату и время, преобразовывать миллисекунды в дату и время, а также преобразовывать прошедшие 1970 секунд в дату и время.
```cpp
QDateTime dateTime;
QString dateTime_str = dateTime.currentDateTime().toString("yyyy-MM-dd hh:mm:ss");
//Преобразование из строки в миллисекунды (требуется полный год, месяц, день, час, минута и секунда)
datetime.fromString("2011-09-10 12:07:50:541", "yyyy-MM-dd hh:mm:ss:zzz").toMSecsSinceEpoch();
//Преобразование из строки в секунды (требуется полный год, месяц, день, час, минута и секунда)
datetime.fromString("2011-09-10 12:07:50:541", "yyyy-MM-dd hh:mm:ss:zzz").toTime_t();
//Преобразование из миллисекунд в год, месяц, день, час, минуту и ​​секунду
datetime.fromMSecsSinceEpoch(1315193829218).toString("yyyy-MM-dd hh:mm:ss:zzz");
//Преобразование из секунд в год, месяц, день, час, минуту и ​​секунду (если есть zzz, то это 000)
datetime.fromTime_t(1315193829).toString("yyyy-MM-dd hh:mm:ss[:zzz]");
```
