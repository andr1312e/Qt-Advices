feiyangqingyun /qtkaifajingyan

1. Когда в компиляции обнаруживается большое количество ошибок, начните с первой и устраняйте их одну за другой. Не спешите увидеть следующую ошибку. Часто последние ошибки вызваны предыдущими ошибками. Могут быть все решено
2. Таймер - хорошая вещь, научитесь его использовать, иногда с помощью одиночного таймера QTimer :: singleShot и QMetaObject :: invokeMethod можно решить неожиданные проблемы. Например, загрузка занимает много времени при инициализации формы, поэтому легко застрять на главном дисплее интерфейса, и интерфейс не будет отображаться до завершения загрузки, что приводит к очень неприятным ощущениям. Загрузка времени (иногда эти загрузки должны выполняться в основном потоке, например, при использовании окна стека QStackWidget для загрузки некоторых подформ), отложенная или асинхронная загрузка, чтобы она выполнялась после отображения интерфейса вместо основного основного интерфейса.
```cpp
//Выполнять функцию загрузки асинхронно
QMetaObject::invokeMethod(this, "load", Qt::QueuedConnection);
//Задержка 10 миллисекунд для выполнения функции загрузки
QTimer::singleShot(10, this, SLOT(load()));
```
3.QtCreator по умолчанию - это однопоточная компиляция. В начале проектирования можно подумать, что он не занимает как можно больше системных ресурсов. В настоящее время компьютеры являются многоядерными. Компилятор msvc по умолчанию - это многопоточная компиляция без ручной настройки. другие компиляторы, вам нужно установить его вручную.
- Метод 1. На этапе сборки параметров сборки каждого проекта (вы можете проверить страницу теневой сборки) добавьте строку -j16 для создания аргументов. Этот параметр будет сохранен в файле pro.user и понадобится, когда он удален Reset, этот метод не рекомендуется;
- Метод 2: Добавьте в среду комплекта сборки, Инструменты-> Параметры-> Комплекты сборки-> Выберите комплект сборки-> среда-> кнопка изменения справа-> Введите MAKEFLAGS = -j4 в открытое поле ввода, В таким образом, вам не нужно каждый раз настраивать многопоточную компиляцию, пока это проект, который использует этот набор компонентов, этот параметр компиляции будет добавлен; 
- Примечание: за -j следует количество ядер компьютера. Если вы напишете слишком много, не будет никакого эффекта. Вы должны проверить параметры компьютера или ввести -j4. Ведь 4 ядра компьютер должен быть самым основным; 
- Вероятно, новая версия QtCreator, начиная с 2019 года, будет автоматически устанавливать многопоточную компиляцию в соответствии с ядром компьютера по умолчанию. Например, если он распознает, что ваш компьютер 16-ядерный, он будет компилироваться с параметром -j16 по умолчанию ; 

4. Если вы хотите использовать QtCreator для беспрепятственного развертывания программ Android, вы должны сначала успешно настроить его в AndroidStudio, чтобы сгладить все неровности. 

5. Много раз после нахождения соответствующего метода инкапсуляции Qt не забывайте больше смотреть на перегрузку функции. Если у вас несколько параметров, вы найдете другой мир, и иногда вы внезапно поймете, что Qt уже инкапсулировал его для us, например, перегруженные параметры QString и QColor чрезвычайно богаты.

6. Вы можете записать номер версии метки + значок ico в файл pro (поддерживается только Qt5) .На самом деле, когда это qmake в Windows, эта информация будет автоматически преобразована в файл rc. 

```cpp
VERSION  = 2025.10.01
RC_ICONS = main.ico
```

7. Администратор запускает программу, ограниченную компилятором MSVC. 
```cpp
QMAKE_LFLAGS += /MANIFESTUAC:"level='requireAdministrator' uiAccess='false'" #Запустить от имени администратора
QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,"5.01" # VS2013 Запуск на XP
```
8. В рабочем файле есть окно вывода отладки. Это очень полезно. Много раз, когда мы выпускаем программу, мы сталкиваемся с тем, что программа дважды щелкает и не запускается без сообщения об ошибке (на машине разработки все в норме. ), и мы не знаем, что произошло, или даже о задаче. Менеджер видит, что она запущена, но интерфейс не появляется. В это время вам нужно добавить это в файл pro проекта. Программа с интерфейсом также автоматически откроет окно отладки, чтобы распечатать информацию, которая удобна для поиска проблем. Как правило, он не может работать нормально. Программа будет печатать некоторые подсказки и так далее. 
```cpp
TEMPLATE    = app
MOC_DIR     = temp/moc
RCC_DIR     = temp/rcc
UI_DIR      = temp/ui
OBJECTS_DIR = temp/obj
# Следующая строка используется для установки рабочего файла с окном вывода отладки 
CONFIG      += console
```
9. Нарисуйте мозаичный фон QPainter :: drawTiledPixmap и нарисуйте прямоугольник с закругленными углами QPainter :: drawRoundedRect () вместо QPainter :: drawRoundRect (); 
10. Удалить старый стиль 
```cpp
//Удалить исходный стиль 
style()->unpolish(ui->btn);
//Должна быть следующая строка, иначе он не будет удален 
ui->btn->setStyleSheet("");
//Сбросьте новый стиль элемента управления.
style()->polish(ui->btn);
```

11.Получить атрибуты класса
```cpp
const QMetaObject *metaobject = object->metaObject();
int count = metaobject->propertyCount();
for (int i = 0; i < count; ++i) {
    QMetaProperty metaproperty = metaobject->property(i);
    const char *name = metaproperty.name();
    QVariant value = object->property(name);
    qDebug() << name << value;
}
```

12. Встроенные значки Qt инкапсулированы в QStyle, и существует около 70 значков, которые можно использовать напрямую. 
```cpp
SP_TitleBarMenuButton,
SP_TitleBarMinButton,
SP_TitleBarMaxButton,
SP_TitleBarCloseButton,
SP_MessageBoxInformation,
SP_MessageBoxWarning,
SP_MessageBoxCritical,
SP_MessageBoxQuestion,
...
//Просто вытащите его и используйте вот так
QPixmap pixmap = this->style()->standardPixmap(QStyle::SP_TitleBarMenuButton);
ui->label->setPixmap(pixmap);
```
13. Оценивайте загрузку по количеству битов операционной системы.
```cpp
win32 {
    contains(DEFINES, WIN64) {
        DESTDIR = $$PWD/../bin64
    } else { 
        DESTDIR = $$PWD/../bin32
    }
}
```

14. Qt5 значительно улучшил проверку безопасности.Если появляется setGeometry: Unable to set geometry, переместите видимость элемента управления после добавления его в макет. 
15. Вы можете добавить элемент управления A в макет, а затем элемент управления B, чтобы задать макет. Такая гибкость улучшает комбинацию элементов управления. Например, вы можете добавить кнопку поиска слева и справа от текстового поля, а кнопку можно установить значок.
```cpp
QPushButton *btn = new QPushButton;
btn->resize(30, ui->lineEdit->height());
QHBoxLayout *layout = new QHBoxLayout(ui->lineEdit);
layout->setMargin(0);
layout->addStretch();
layout->addWidget(btn);
```

16. Чтобы установить стиль элемента управления QLCDNumber, вам необходимо установить стиль сегмента QLCDNumber на плоский, иначе вы не обнаружите никакого эффекта.

17. Умное использование findChildren позволяет находить все дочерние элементы управления под элементом управления. findChild - найти сингл.
```cpp
//Найдите элемент управления с указанным именем класса objectName
QList<QWidget *> widgets = fatherWidget.findChildren<QWidget *>("widgetname");
//Найти все QPushButton
QList<QPushButton *> allPButtons = fatherWidget.findChildren<QPushButton *>();
//Найдите подэлемент управления первого уровня, иначе он всегда будет проходить через все подэлементы управления.
QList<QPushButton *> childButtons = fatherWidget.findChildren<QPushButton *>(QString(), Qt::FindDirectChildrenOnly);
```
18. Используйте наследование с умом, чтобы определить, принадлежит ли оно к определенной категории.
`` cpp
QTimer * timer = new QTimer; // QTimer наследует QObject
timer-> inherits ("QTimer"); // возвращает истину
timer-> inherits ("QObject"); // возвращает истину
timer-> inherits ("QAbstractButton"); // возвращает false
`` '' 

19. Используя механизм слабых атрибутов, временные значения могут быть сохранены для принятия решения о передаче. Вы можете перечислить все имена слабых свойств с помощью widget-> dynamicPropertyNames (), а затем получить значение соответствующего слабого свойства с помощью widget-> property ("name"). 
20. Во время разработки, будь то для удобства обслуживания или из соображений экономии ресурсов памяти, должен быть файл qss для хранения всех таблиц стилей, а setStyleSheet не следует писать везде. Если это начальный этап или этап тестирования, вы можете щелкнуть правой кнопкой мыши пользовательский интерфейс, чтобы установить таблицу стилей.Для формальных проектов лучше объединить файл таблицы стилей в файл таблицы стилей qss для унифицированного управления. 
21. Если появляется сообщение об ошибке Z-order_assignment: is_not_a_valid_widget., Откройте соответствующий файл пользовательского интерфейса с помощью Блокнота, найдите место, где <zorder> </zorder> пуст, и удалите его.
22. Уметь использовать второй параметр addItem ComboBox для установки пользовательских данных, которые могут дать множество эффектов, и использовать _itemData, чтобы получить их.
23.  Если используется модуль webengine, принесите QtWebEngineProcess.exe + папку переводов + папку ресурсов при публикации программы. 
24.  По умолчанию Qt является дескриптором окна.Если вы хотите, чтобы каждый элемент управления имел независимый дескриптор, установите a.setAttribute (Qt :: AA_NativeWindows); 
25.  Qt + Android предотвращает закрытие программы. 
```cpp
#if defined(Q_OS_ANDROID)
QAndroidService a(argc, argv);
return a.exec()
#else
QApplication a(argc, argv);
return a.exec();
#endif
```
26. Вы можете установить стиль общего индикатора вместо индивидуальной настройки индикатора для каждого элемента управления.
```cpp
*::down-arrow{}
*::menu-indicator{}
*::up-arrow:disabled{}
*::up-arrow:off{}
```
27. Вы можете установить фоновое изображение в указанном месте. 
```cpp
QMainWindow > .QWidget {
    background-color: gainsboro;
    background-image: url(:/images/pagefold.png);
    background-position: top right;
    background-repeat: no-repeat
}
```
28. Встроенный Linux, работающий с программой Qt 
```cpp
//Написание Qt4
./HelloQt -qws &

//Формулировка Qt5 xcb может быть изменена на linuxfb eglfs vnc wayland и т. Д., Используйте то, что нужно для тестирования, по очереди
./HelloQt --platform xcb
./HelloQt --platform wayland
```
29. Файл конфигурации программного обеспечения Qtcreator хранится по адресу: C: \ Users \ Administrator \ AppData \ Roaming \ QtProject. Иногда, если что-то пойдет не так, удалите эту папку и откройте создатель, чтобы автоматически восстановить ее. 
30. QMediaPlayer - это оболочка (также может называться фреймворком), использующая локальный декодер, видео в основном воспроизводит MP4 по умолчанию, и даже MP4 не может быть воспроизведен. Если вы хотите поддерживать другие форматы, вам необходимо загрузить k -lite или LAV Filters и установите его. (K-lite или LAV Filters относятся к окнам, ищите в других системах самостоятельно, похоже, что встроенный linux полагается на GStreamer, который не был полностью проверен). Если вам нужен мощный проигрыватель, новички рекомендуют использовать vlc, mpv и окончательный универсальный метод с использованием ffmpeg (декодированное видео можно нарисовать с помощью QOpenGLWidget с помощью графического процессора или преобразовать в QImage для рисования, а аудиоданные можно воспроизвести с помощью QAudioOutput).
31. Определите тип компилятора, версию компилятора и операционную систему.
```cpp
//Компилятор GCC
#ifdef __GNUC__
#if __GNUC__ >= 3   // GCC3.0  выше

//Компилятор MSVC
#ifdef _MSC_VER
#if _MSC_VER >=1000 // VC++4.0 выше
#if _MSC_VER >=1100 // VC++5.0 выше
#if _MSC_VER >=1200 // VC++6.0 выше
#if _MSC_VER >=1300 // VC2003  выше
#if _MSC_VER >=1400 // VC2005  выше
#if _MSC_VER >=1500 // VC2008  выше
#if _MSC_VER >=1600 // VC2010  выше
#if _MSC_VER >=1700 // VC2012  выше
#if _MSC_VER >=1800 // VC2013  выше
#if _MSC_VER >=1900 // VC2015  выше

//Borland C++
#ifdef __BORLANDC__

//Cygwin
#ifdef __CYGWIN__
#ifdef __CYGWIN32__

//mingw
#ifdef __MINGW32__

//windows
#ifdef _WIN32           //32bit
#ifdef _WIN64           //64bit
#ifdef _WINDOWS         //Программа с графическим интерфейсом
#ifdef _CONSOLE         //Консольная программа

//Windows（95/98/Me/NT/2000/XP/Vista）И Windows CE определила
#if (WINVER >= 0x030a)  // Windows 3.1 выше
#if (WINVER >= 0x0400)  // Windows 95/NT4.0 выше
#if (WINVER >= 0x0410)  // Windows 98 выше
#if (WINVER >= 0x0500)  // Windows Me/2000 выше
#if (WINVER >= 0x0501)  // Windows XP выше
#if (WINVER >= 0x0600)  // Windows Vista выше

//_WIN32_WINNT версия ядра
#if (_WIN32_WINNT >= 0x0500) // Windows 2000 выше
#if (_WIN32_WINNT >= 0x0501) // Windows XP выше
#if (_WIN32_WINNT >= 0x0600) // Windows Vista выше

```
