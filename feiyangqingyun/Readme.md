ссылки
https://evgenykislov.com/wp-content/custom/cpp_codestyle/cppguide_ru.html

feiyangqingyun /qtkaifajingyan

1. Когда в компиляции обнаруживается большое количество ошибок, начните с первой и устраняйте их одну за другой. Не спешите увидеть следующую ошибку. Часто последние ошибки вызваны предыдущими ошибками. Могут быть все решено
2. Таймер - хорошая вещь, научитесь его использовать, иногда с помощью одиночного таймера QTimer :: singleShot и QMetaObject :: invokeMethod можно решить неожиданные проблемы. Например, загрузка занимает много времени при инициализации формы, поэтому легко застрять на главном дисплее интерфейса, и интерфейс не будет отображаться до завершения загрузки, что приводит к очень неприятным ощущениям. Загрузка времени (иногда эти загрузки должны выполняться в основном потоке, например, при использовании окна стека QStackWidget для загрузки некоторых подформ), отложенная или асинхронная загрузка, чтобы она выполнялась после отображения интерфейса вместо основного основного интерфейса.
```cpp
//Выполнять функцию загрузки асинхронно
QMetaObject::invokeMethod(this, "load", Qt::QueuedConnection);
//Задержка 10 миллисекунд для выполнения функции загрузки
QTimer::singleShot(10, this, SLOT(load()));
```
3.QtCreator по умолчанию - это однопоточная компиляция. В начале проектирования можно подумать, что он не занимает как можно больше системных ресурсов. В настоящее время компьютеры являются многоядерными. Компилятор msvc по умолчанию - это многопоточная компиляция без ручной настройки. другие компиляторы, вам нужно установить его вручную.
- Метод 1. На этапе сборки параметров сборки каждого проекта (вы можете проверить страницу теневой сборки) добавьте строку -j16 для создания аргументов. Этот параметр будет сохранен в файле pro.user и понадобится, когда он удален Reset, этот метод не рекомендуется;
- Метод 2: Добавьте в среду комплекта сборки, Инструменты-> Параметры-> Комплекты сборки-> Выберите комплект сборки-> среда-> кнопка изменения справа-> Введите MAKEFLAGS = -j4 в открытое поле ввода, В таким образом, вам не нужно каждый раз настраивать многопоточную компиляцию, пока это проект, который использует этот набор компонентов, этот параметр компиляции будет добавлен; 
- Примечание: за -j следует количество ядер компьютера. Если вы напишете слишком много, не будет никакого эффекта. Вы должны проверить параметры компьютера или ввести -j4. Ведь 4 ядра компьютер должен быть самым основным; 
- Вероятно, новая версия QtCreator, начиная с 2019 года, будет автоматически устанавливать многопоточную компиляцию в соответствии с ядром компьютера по умолчанию. Например, если он распознает, что ваш компьютер 16-ядерный, он будет компилироваться с параметром -j16 по умолчанию ; 

4. Если вы хотите использовать QtCreator для беспрепятственного развертывания программ Android, вы должны сначала успешно настроить его в AndroidStudio, чтобы сгладить все неровности. 

5. Много раз после нахождения соответствующего метода инкапсуляции Qt не забывайте больше смотреть на перегрузку функции. Если у вас несколько параметров, вы найдете другой мир, и иногда вы внезапно поймете, что Qt уже инкапсулировал его для us, например, перегруженные параметры QString и QColor чрезвычайно богаты.

6. Вы можете записать номер версии метки + значок ico в файл pro (поддерживается только Qt5) .На самом деле, когда это qmake в Windows, эта информация будет автоматически преобразована в файл rc. 

```cpp
VERSION  = 2025.10.01
RC_ICONS = main.ico
```

7. Администратор запускает программу, ограниченную компилятором MSVC. 
```cpp
QMAKE_LFLAGS += /MANIFESTUAC:"level='requireAdministrator' uiAccess='false'" #Запустить от имени администратора
QMAKE_LFLAGS += /SUBSYSTEM:WINDOWS,"5.01" # VS2013 Запуск на XP
```
8. В рабочем файле есть окно вывода отладки. Это очень полезно. Много раз, когда мы выпускаем программу, мы сталкиваемся с тем, что программа дважды щелкает и не запускается без сообщения об ошибке (на машине разработки все в норме. ), и мы не знаем, что произошло, или даже о задаче. Менеджер видит, что она запущена, но интерфейс не появляется. В это время вам нужно добавить это в файл pro проекта. Программа с интерфейсом также автоматически откроет окно отладки, чтобы распечатать информацию, которая удобна для поиска проблем. Как правило, он не может работать нормально. Программа будет печатать некоторые подсказки и так далее. 
```cpp
TEMPLATE    = app
MOC_DIR     = temp/moc
RCC_DIR     = temp/rcc
UI_DIR      = temp/ui
OBJECTS_DIR = temp/obj
# Следующая строка используется для установки рабочего файла с окном вывода отладки 
CONFIG      += console
```
9. Нарисуйте мозаичный фон QPainter :: drawTiledPixmap и нарисуйте прямоугольник с закругленными углами QPainter :: drawRoundedRect () вместо QPainter :: drawRoundRect (); 
10. Удалить старый стиль 
```cpp
//Удалить исходный стиль 
style()->unpolish(ui->btn);
//Должна быть следующая строка, иначе он не будет удален 
ui->btn->setStyleSheet("");
//Сбросьте новый стиль элемента управления.
style()->polish(ui->btn);
```

11.Получить атрибуты класса
```cpp
const QMetaObject *metaobject = object->metaObject();
int count = metaobject->propertyCount();
for (int i = 0; i < count; ++i) {
    QMetaProperty metaproperty = metaobject->property(i);
    const char *name = metaproperty.name();
    QVariant value = object->property(name);
    qDebug() << name << value;
}
```

12. Встроенные значки Qt инкапсулированы в QStyle, и существует около 70 значков, которые можно использовать напрямую. 
```cpp
SP_TitleBarMenuButton,
SP_TitleBarMinButton,
SP_TitleBarMaxButton,
SP_TitleBarCloseButton,
SP_MessageBoxInformation,
SP_MessageBoxWarning,
SP_MessageBoxCritical,
SP_MessageBoxQuestion,
...
//Просто вытащите его и используйте вот так

QPixmap pixmap = this->style()->standardPixmap(QStyle::SP_TitleBarMenuButton);
ui->label->setPixmap(pixmap);

```
13. Оценивайте загрузку по количеству битов операционной системы.
```cpp
win32 {
    contains(DEFINES, WIN64) {
        DESTDIR = $$PWD/../bin64
    } else { 
        DESTDIR = $$PWD/../bin32
    }
}
```

14. Qt5 значительно улучшил проверку безопасности.Если появляется setGeometry: Unable to set geometry, переместите видимость элемента управления после добавления его в макет. 
15. Вы можете добавить элемент управления A в макет, а затем элемент управления B, чтобы задать макет. Такая гибкость улучшает комбинацию элементов управления. Например, вы можете добавить кнопку поиска слева и справа от текстового поля, а кнопку можно установить значок.
```cpp
QPushButton *btn = new QPushButton;
btn->resize(30, ui->lineEdit->height());
QHBoxLayout *layout = new QHBoxLayout(ui->lineEdit);
layout->setMargin(0);
layout->addStretch();
layout->addWidget(btn);
```

16. Чтобы установить стиль элемента управления QLCDNumber, вам необходимо установить стиль сегмента QLCDNumber на плоский, иначе вы не обнаружите никакого эффекта.

17. Умное использование findChildren позволяет находить все дочерние элементы управления под элементом управления. findChild - найти сингл.
```cpp
//Найдите элемент управления с указанным именем класса objectName
QList<QWidget *> widgets = fatherWidget.findChildren<QWidget *>("widgetname");

//Найти все QPushButton
QList<QPushButton *> allPButtons = fatherWidget.findChildren<QPushButton *>();

//Найдите подэлемент управления первого уровня, иначе он всегда будет проходить через все подэлементы управления.
QList<QPushButton *> childButtons = fatherWidget.findChildren<QPushButton *>(QString(), Qt::FindDirectChildrenOnly);

```
18. Используйте наследование с умом, чтобы определить, принадлежит ли оно к определенной категории.
`` cpp
QTimer * timer = new QTimer; // QTimer наследует QObject

timer-> inherits ("QTimer"); // возвращает истину

timer-> inherits ("QObject"); // возвращает истину

timer-> inherits ("QAbstractButton"); // возвращает false
`` '' 

19. Используя механизм слабых атрибутов, временные значения могут быть сохранены для принятия решения о передаче. Вы можете перечислить все имена слабых свойств с помощью widget-> dynamicPropertyNames (), а затем получить значение соответствующего слабого свойства с помощью widget-> property ("name"). 
20. Во время разработки, будь то для удобства обслуживания или из соображений экономии ресурсов памяти, должен быть файл qss для хранения всех таблиц стилей, а setStyleSheet не следует писать везде. Если это начальный этап или этап тестирования, вы можете щелкнуть правой кнопкой мыши пользовательский интерфейс, чтобы установить таблицу стилей.Для формальных проектов лучше объединить файл таблицы стилей в файл таблицы стилей qss для унифицированного управления. 
21. Если появляется сообщение об ошибке Z-order_assignment: is_not_a_valid_widget., Откройте соответствующий файл пользовательского интерфейса с помощью Блокнота, найдите место, где <zorder> </zorder> пуст, и удалите его.
22. Уметь использовать второй параметр addItem ComboBox для установки пользовательских данных, которые могут дать множество эффектов, и использовать _itemData, чтобы получить их.
23.  Если используется модуль webengine, принесите QtWebEngineProcess.exe + папку переводов + папку ресурсов при публикации программы. 
24.  По умолчанию Qt является дескриптором окна.Если вы хотите, чтобы каждый элемент управления имел независимый дескриптор, установите a.setAttribute (Qt :: AA_NativeWindows); 
25.  Qt + Android предотвращает закрытие программы. 
```cpp
#if defined(Q_OS_ANDROID)
QAndroidService a(argc, argv);
return a.exec()
#else
QApplication a(argc, argv);
return a.exec();
#endif
```
26. Вы можете установить стиль общего индикатора вместо индивидуальной настройки индикатора для каждого элемента управления.
```cpp
*::down-arrow{}
*::menu-indicator{}
*::up-arrow:disabled{}
*::up-arrow:off{}
```
27. Вы можете установить фоновое изображение в указанном месте. 
```cpp
QMainWindow > .QWidget {
    background-color: gainsboro;
    background-image: url(:/images/pagefold.png);
    background-position: top right;
    background-repeat: no-repeat
}
```
28. Встроенный Linux, работающий с программой Qt 
```cpp
//Написание Qt4
./HelloQt -qws &

//Формулировка Qt5 xcb может быть изменена на linuxfb eglfs vnc wayland и т. Д., Используйте то, что нужно для тестирования, по очереди
./HelloQt --platform xcb
./HelloQt --platform wayland
```
29. Файл конфигурации программного обеспечения Qtcreator хранится по адресу: C: \ Users \ Administrator \ AppData \ Roaming \ QtProject. Иногда, если что-то пойдет не так, удалите эту папку и откройте создатель, чтобы автоматически восстановить ее. 
30. QMediaPlayer - это оболочка (также может называться фреймворком), использующая локальный декодер, видео в основном воспроизводит MP4 по умолчанию, и даже MP4 не может быть воспроизведен. Если вы хотите поддерживать другие форматы, вам необходимо загрузить k -lite или LAV Filters и установите его. (K-lite или LAV Filters относятся к окнам, ищите в других системах самостоятельно, похоже, что встроенный linux полагается на GStreamer, который не был полностью проверен). Если вам нужен мощный проигрыватель, новички рекомендуют использовать vlc, mpv и окончательный универсальный метод с использованием ffmpeg (декодированное видео можно нарисовать с помощью QOpenGLWidget с помощью графического процессора или преобразовать в QImage для рисования, а аудиоданные можно воспроизвести с помощью QAudioOutput).
31. Определите тип компилятора, версию компилятора и операционную систему.
```cpp
//Компилятор GCC
#ifdef __GNUC__
#if __GNUC__ >= 3   // GCC3.0  выше

//Компилятор MSVC
#ifdef _MSC_VER
#if _MSC_VER >=1000 // VC++4.0 выше
#if _MSC_VER >=1100 // VC++5.0 выше
#if _MSC_VER >=1200 // VC++6.0 выше
#if _MSC_VER >=1300 // VC2003  выше
#if _MSC_VER >=1400 // VC2005  выше
#if _MSC_VER >=1500 // VC2008  выше
#if _MSC_VER >=1600 // VC2010  выше
#if _MSC_VER >=1700 // VC2012  выше
#if _MSC_VER >=1800 // VC2013  выше
#if _MSC_VER >=1900 // VC2015  выше

//Borland C++
#ifdef __BORLANDC__

//Cygwin
#ifdef __CYGWIN__
#ifdef __CYGWIN32__

//mingw
#ifdef __MINGW32__

//windows
#ifdef _WIN32           //32bit
#ifdef _WIN64           //64bit
#ifdef _WINDOWS         //Программа с графическим интерфейсом
#ifdef _CONSOLE         //Консольная программа

//Windows（95/98/Me/NT/2000/XP/Vista）И Windows CE определила
#if (WINVER >= 0x030a)  // Windows 3.1 выше
#if (WINVER >= 0x0400)  // Windows 95/NT4.0 выше
#if (WINVER >= 0x0410)  // Windows 98 выше
#if (WINVER >= 0x0500)  // Windows Me/2000 выше
#if (WINVER >= 0x0501)  // Windows XP выше
#if (WINVER >= 0x0600)  // Windows Vista выше

//_WIN32_WINNT версия ядра
#if (_WIN32_WINNT >= 0x0500) // Windows 2000 выше
#if (_WIN32_WINNT >= 0x0501) // Windows XP выше
#if (_WIN32_WINNT >= 0x0600) // Windows Vista выше

```

32. Определите версию Qt и количество пакетов сборки в pro 
```cpp
# Распечатать информацию о версии
message(qt version: $$QT_VERSION)
# Оценка текущего номера версии qt
QT_VERSION = $$[QT_VERSION]
QT_VERSION = $$split(QT_VERSION, ".")
QT_VER_MAJ = $$member(QT_VERSION, 0)
QT_VER_MIN = $$member(QT_VERSION, 1)
# Следующее для Qt5.5 и выше
greaterThan(QT_VER_MAJ, 4) {
greaterThan(QT_VER_MIN, 4) {
# Выполните некоторую обработку в соответствии с вашими потребностями
}}

#QT_ARCH является новым в Qt5 и не влияет на Qt4
# Распечатать информацию о текущем комплекте сборки Qt
message($$QT_ARCH)
# Указывает комплект сборки платформы _arm
contains(QT_ARCH, arm) {}
# Указывает на 32-битный комплект сборки
contains(QT_ARCH, i386) {}
# Указывает на 64-битный комплект сборки
contains(QT_ARCH, x86_64) {}

# Фактически, Qt имеет встроенные переменные номера основной версии и номера подверсии
# Оценка текущего номера версии qt
message($$QT_ARCH : $$QT_VERSION -> $$QT_MAJOR_VERSION . $$QT_MINOR_VERSION)

# Значение ниже, если версия <4.8
lessThan(QT_MAJOR_VERSION, 5) {
lessThan(QT_MINOR_VERSION, 8) {
# Здесь нужно выполнить обработку
}}

# Значение ниже, если версия> = 5.5
greaterThan(QT_MAJOR_VERSION, 4) {
greaterThan(QT_MINOR_VERSION, 4) {
# Здесь нужно выполнить обработку
}}

// Не судите версию в коде слишком просто
#if (QT_VERSION >= QT_VERSION_CHECK(6,0,0))
// Вот что делать
#endif
```

33. После сворачивания Qt интерфейс будет восстановлен до зависания и зависания, плюс код
```cpp
void showEvent(QShowEvent *e)
{
    setAttribute(Qt::WA_Mapped);
    QWidget::showEvent(e);
}
```
34. Получите высоту строки заголовка: style () -> pixelMetric (QStyle :: PM TitleBarHeight); Щелкните PM TitleBarHeight, и вы найдете новый мир.
35. Установите свойства экрана с высоким разрешением для поддержки высоких разрешений, таких как 2K4K, особенно для мобильных телефонов. app。Должен быть написан на main   Функциональный QApplication a(argc, argv);Спереди.
```cpp
#if (QT_VERSION > QT_VERSION_CHECK(5,6,0))
    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
#endif
    QApplication a(argc, argv);
```
36. Если запущенная программа появляется Fault tolerant heap shim applied to current process. This is usually due to previous crashes.Ошибка。
- Шаг 1: введите команду regedit Откройте реестр；
- Шаг 2: Найдите узел HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers\；
- Шаг 3: выберите Layers Ключ-значение, удалите собственный путь к программе из списка справа.
37. Встроенная в Qt компоновка формы QFormLayout используется для автоматической генерации интерфейса формы комбинации метки + поля ввода. Она редко используется для установки компоновки, и наиболее часто используются горизонтальная компоновка, вертикальная компоновка и компоновка таблицы. .
38. Qml для воспроизведения видео необходимо установить в Linux sudo apt-get install libpulse-dev.
39. Вы можете напрямую наследовать QSqlQueryModel для реализации пользовательской модели QueryModel, такой как цвет шрифта столбца, заполнитель, другие стили и т. Д., И переписать QVariant CustomSqlModel :: data (const QModelIndex & index, int role) const.
40. После Qt5 предоставляется класс QScroller для прямой прокрутки элемента управления.
```cpp
//Отключить горизонтальную полосу прокрутки
ui->listWidget->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//Отключить вертикальную полосу прокрутки
ui->listWidget->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//Установите горизонтальную прокрутку в соответствии со значением пикселя
ui->listWidget->setHorizontalScrollMode(QListWidget::ScrollPerPixel);
//Установите вертикальную прокрутку в соответствии со значением пикселя
ui->listWidget->setVerticalScrollMode(QListWidget::ScrollPerPixel);
//Установите объект прокрутки и метод прокрутки для прокрутки левой кнопкой мыши
QScroller::grabGesture(ui->listWidget, QScroller::LeftMouseButtonGesture);
//Также есть QScrollerProperties, который может устанавливать некоторые параметры прокрутки.
```

41. Если вы не хотите создавать файл базы данных при использовании базы данных sqlite, вы можете создать базу данных в памяти.
```cpp
QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE");
db.setDatabaseName(":memory:");
```
42. Очистите таблицу данных и сбросьте самоинкремент ID，sql = truncate table table_name。

43. Qtchart Модуль от Qt5.7 Он идет вместе с ним, а минимальная компиляция требует Qt5.4. Не забудьте проверить это во время установки, по умолчанию он не отмечен. Использование этого модуля требует введения пространства имен.
```cpp
#include <QChartView>
QT_CHARTS_USE_NAMESPACE
class CustomChart : public QChartView
```
44. QPushButton Текст с выравниванием по левому краю, необходимо установить таблицу стилей QPushButton{text-align:left;}

45. QLabel Есть три способа установить текст, освоить систему атрибутов Qt и сделать выводы друг из друга, вы можете добиться множества эффектов.
```cpp
//Традиционный подход
ui->label->setText("hello");
//Трюки
ui->label->setProperty("text", "hello");
//Атрибут Дафа
ui->label->setStyleSheet("qproperty-text:hello;");
```
46. Умное использование QEventLoop Включение цикла обработки событий может привести к синхронному извлечению и возврату результатов без блокировки интерфейса. Проверьте исходный код, оказывается QEventLoop Выполнение потока создается заново внутри.
```cpp
QEventLoop loop;
connect(reply, SIGNAL(finished()), &loop, SLOT(quit()));
loop.exec();
```

47. Несколько предопределенных переменных #if (defined webkit) || (defined webengine)，Удалите сгенерированный пустой debug и release содержание CONFIG -= debug_and_release。

48. Новая версия Qtcreator Расширенная проверка грамматики, появится много предупреждений и т. Д., Можно закрыть в списке плагинов clang Только первые несколько ，Help》About Plugins。Вы также можете установить уровень проверки кода，Tools》Options 》C++ 》Code Model。
49. QSqlTableModel из rowCount Метод, максимальная доходность по умолчанию 256，Если он превышает 256，Вы можете потянуть стол вниз, он автоматически загрузит оставшиеся, каждый раз самая большая загрузка 256 Данные панели. Если вам нужно распечатать или экспортировать данные, помните, что лучше всего использовать sql Заявление для просмотра вместо использования QSqlTableModel из rowCount метод. В противном случае это всегда будет самый крупный и единственный экспорт. 256 Данные статьи.
Если объем данных невелик, можно также использовать следующие методы:
```cpp
//Активно загружать все данные, иначе количество строк получится<=256
while(model->canFetchMore()) {
    model->fetchMore();
}
```

50. Если вам нужно указать окно без полей, но вам нужно сохранить характеристики границ операционной системы, вы можете свободно растянуть границу, вы можете использовать setWindowFlags(Qt::CustomizeWindowHint);
51. В некоторых http post При отправке данных, если вы используете для отправки данные соединения _string, если китайский язык анализирует искаженные символы, вам необходимо перекодировать китайский URL.
```cpp
QString content = "测试中文";
QString note = content.toUtf8().toPercentEncoding();
```

52. Qt По умолчанию большие файлы ресурсов не поддерживаются. Например, если добавляются файлы шрифтов, вам потребуется pro Файл открыт。
CONFIG += resources_big


53. После наследования QWidget в Qt таблица стилей не работает.Есть три решения. Настоятельно рекомендуется первый метод.
- Метод 1: установить атрибут this-> setAttribute (Qt :: WA_StyledBackground, true);
- Метод 2: изменить наследование QFrame, потому что QFrame имеет свою собственную функцию paintEvent, которая была реализована, и она будет проанализирована и отрисована при использовании таблицы стилей.
- Метод 3: при повторной реализации функции paintEvent QWidget использовать для рисования QStylePainter. 
```cpp
void Widget::paintEvent(QPaintEvent *)
{
    QStyleOption option;
    option.initFrom(this);
    QPainter painter(this);
    style()->drawPrimitive(QStyle::PE_Widget, &option, &painter, this);
}
```

54. Иногда к интерфейсу добавляется пружина, и стратегию растяжения, соответствующую пружине, необходимо динамически изменять. Соответствующий метод - changeSize，Многие люди предпочтут использовать set Я нашел это в начале, я не мог найти。
55. В процессе использования QFile не рекомендуется часто открывать файл для записи, а затем закрывать файл. Например, выводить журнал каждые 5 мсек. Узкое место производительности ввода-вывода очень велико. В этом случае рекомендуется открывать файл сначала и не закрывайте его, и дождитесь подходящего времени, такого как деструктор.Закройте файл, когда файл журнала необходимо снова изменить, когда изменилась дата. В противном случае открытие и закрытие большого количества файлов за короткий промежуток времени будет очень зависнуть, чем больше файл, тем больше зависает.
56. Во многих сетевых приложениях для поддержания соединения требуется настраиваемый контрольный пакет. В противном случае отключится питание или программа будет незаконно закрыта, и другая сторона не сможет ее распознать. Требуется обнаружение тайм-аута. Однако некоторые программы не обеспечивают протокол подтверждения. В настоящее время необходимо включить поддержку активности на уровне системы. Процедура, этот метод подходит для TCP-соединения.
```cpp
int fd = tcpSocket->socketDescriptor();
int keepAlive = 1;      //Включить атрибут keepalive, значение по умолчанию: 0 (закрыто)
int keepIdle = 5;       //Если нет взаимодействия с данными в течение 5 секунд, обнаружение будет выполнено, значение по умолчанию: 7200 (с)
int keepInterval = 2;   //Интервал времени для отправки пакетов обнаружения во время обнаружения составляет 2 секунды, значение по умолчанию: 75 (с).
int keepCount = 2;      //Количество повторных попыток обнаружения, если все таймауты, соединение считается недействительным, значение по умолчанию: 9 (раз)
setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (void *)&keepAlive, sizeof(keepAlive));
setsockopt(fd, SOL_TCP, TCP_KEEPIDLE, (void *)&keepIdle, sizeof(keepIdle));
setsockopt(fd, SOL_TCP, TCP_KEEPINTVL, (void *)&keepInterval, sizeof(keepInterval));
setsockopt(fd, SOL_TCP, TCP_KEEPCNT, (void *)&keepCount, sizeof(keepCount));
```
57. Если программа упакована, появится всплывающее окно This application failed to start because it could not find or load the Qt platform plugin 一Обычно это вызвано тем, что каталог плагинов платформы не упакован или упакован неправильно.


58. Не рекомендуется включать китайский язык в tr. Хотя новая версия Qt поддерживает перевод с китайского на другие языки, он не стандартизирован, и я не знаю, кто преподавал TMD. Первоначальное значение tr - включить английский, а затем перевести его на другие языки, такие как китайский. В настоящее время большое количество новичков злоупотребляют tr. Если нет необходимости в переводе, tr отключен, а tr требует накладных расходов. По умолчанию Qt будет думать, что ему нужен перевод, и выполнит дополнительная специальная обработка.
59. Многие люди глупо не знают разницы между Qt и Qt Creator. Они часто спрашивают, какая версия Qt и результат - версия Qt Creator. Qt Creator - это интегрированная среда разработки IDE, написанная Qt. вселенная, это может быть компилятор msvc (Qt Cerator, который поставляется с интегрированной установочной средой Qt, соответствующей WIN, - это msvc), он также может быть скомпилирован с помощью mingw или gcc. Если это подключаемый модуль настраиваемого элемента управления, он должен быть интегрирован в Qt Creator, а компилятор, соответствующий файлу динамической библиотеки (файл dll или другой) подключаемого модуля, должен быть точно таким же, как версия Qt и версия количество бит и версию Qt Creator, иначе вряд ли он будет интегрирован. Особое внимание уделяется версии Qt в установочном пакете интегрированной среды Qt, и версия Qt Creator может быть не совсем такой же, вы должны держать глаза открытыми, чтобы ясно видеть, некоторые из них точно такие же.
60. Рекомендуется писать отдельные функции для более чем двух одинаковых кодов обработки. Код должен быть как можно более стандартным и кратким. Например, ``if (a == 123)`` нужно записать как ``if (123 == a)`` со значением впереди и, например, ``if (ok == true)`` следует писать как ``if (ok)`` ,``if (ok == false)``следует писать как`` if (! ok) ``и т. д.
61. Многие люди спрашивают, какая встроенная платформа Qt лучше, и вот единый ответ (текущий узел времени 2018): imx6 + 335x относительно стабилен, высокая производительность, используйте RK3288 RK3399, если это дешево, используйте Allwinner H3, поиграйте с Raspberry Pie апельсиновый пирог.
62. Для большого фрагмента кода комментария рекомендуется использовать #if 0 #endif, чтобы включить блок кода, вместо того, чтобы выбирать код и комментировать все его двойными косыми чертами. Если вы хотите открыть этот код в следующий раз, вам нужно повторно выбрать его и отмените снова. Если вы используете #if 0, вам нужно только изменить 0 на 1, что значительно повысит эффективность разработки.
63. Есть много способов упаковать и выпустить Qt. После Qt5 он предоставляет упаковочный инструмент windeployqt (linuxdeployqt в Linux, macdeployqt в Mac), который может быть очень удобным для упаковки приложений. После его использования он не всемогущ. больше пакетов.Зависимые файлы, иногда вы забываете упаковать некоторые плагины, особенно когда используется qml, и сторонние библиотеки не могут быть распознаны.Например, если программа зависит от ffmpeg, соответствующую библиотеку нужно скопировать самостоятельно . Самый лучший метод - скопировать исполняемый файл. Скопировать его в каталог bin в каталоге установки Qt, а затем упаковать весь пакет вместе и удалить компоненты, которые вряд ли будут зависеть от одного за другим, пока нормальная операция не будет удалена. .
64. Анимация в Qt, нижний уровень использует таймер QElapsedTimer для завершения обработки, такой как генерация некоторых данных определенного алгоритма правила, а затем обработка атрибутов.
65. При рисовании круга без цвета фона и только с цветом границы вы можете заменить его дугой на 360 градусов, и эффект будет точно таким же.
```cpp
QRect rect(-radius, -radius, radius * 2, radius * 2);
//Выберите один из следующих двух методов. На самом деле, рисование дуги на 360 градусов = рисование круга без фона.
painter->drawArc(rect, 0, 360 * 16);
painter->drawEllipse(rect);
```
66. Не смотрите на указатель d очень загадочно. Фактически, частный класс определен в файле реализации класса для хранения локальных переменных. Я лично считаю, что при выполнении некоторых небольших проектов нет особой необходимости вводить этот механизм , что снизит производительность кода.Читаемость увеличивает сложность, и новички будут сбиты с толку после принятия проекта.
67. Когда многие люди рисуют, настраивая кисть, они думают, что могут установить только монотонный цвет. Фактически, QPen также может настраивать кисть, поэтому гибкость увеличивается во много раз. Например, после настройки кисти QPen, вы можете использовать различные градиенты, например, рисовать индикаторы выполнения и текст в градиентных цветах вместо монотонного цвета.
68. Многие элементы управления имеют область просмотра, например QTextEdit / QTableWidget / QScrollArea. Иногда, когда эти элементы управления обрабатываются напрямую, обнаруживается, что это не работает. Вам необходимо установить viewport (). Например, чтобы установить фон прокрутки Чтобы область полосы была прозрачной, вам необходимо использовать scrollArea-> viewport () -> setStyleSheet ("background-color: transparent;"); вместо scrollArea-> setStyleSheet ("QScrollArea {background-color: transparent;}");
69. Иногда для setMouseTracking отслеживания мыши задано значение true. Если в форме есть другие элементы управления, когда мышь перемещается к другим элементам управления, родительское событие движения мыши MouseMove не может быть распознано. В это время необходимо событие HoverMove. Сначала установите setAttribute (Qt :: WA_Hover, истина);
70. Класс даты и времени QDateTime, инкапсулированный в Qt, очень мощный: он может преобразовывать строки символов и дату и время, преобразовывать миллисекунды в дату и время, а также преобразовывать прошедшие 1970 секунд в дату и время.
```cpp
QDateTime dateTime;
QString dateTime_str = dateTime.currentDateTime().toString("yyyy-MM-dd hh:mm:ss");
//Преобразование из строки в миллисекунды (требуется полный год, месяц, день, час, минута и секунда)
datetime.fromString("2011-09-10 12:07:50:541", "yyyy-MM-dd hh:mm:ss:zzz").toMSecsSinceEpoch();
//Преобразование из строки в секунды (требуется полный год, месяц, день, час, минута и секунда)
datetime.fromString("2011-09-10 12:07:50:541", "yyyy-MM-dd hh:mm:ss:zzz").toTime_t();
//Преобразование из миллисекунд в год, месяц, день, час, минуту и ​​секунду
datetime.fromMSecsSinceEpoch(1315193829218).toString("yyyy-MM-dd hh:mm:ss:zzz");
//Преобразование из секунд в год, месяц, день, час, минуту и ​​секунду (если есть zzz, то это 000)
datetime.fromTime_t(1315193829).toString("yyyy-MM-dd hh:mm:ss[:zzz]");
```
71. В процессе использования связанных списков или массивов, таких как ``QList``, ``QStringList``, ``QByteArray`` и т. Д., Если вам нужно только получить значения вместо присвоения значений, настоятельно рекомендуется использовать at () вместо оператора []. В официальной книге «Программирование на C ++ GUI Qt 4» (второе издание) «этой книге сделан особый акцент. Утверждается, что первоначальный автор этого учебника написан основными разработчиками Qt, поэтому он по-прежнему является относительно авторитетным. для сравнения скорости и эффективности использования ``at ()`` и использования оператора ``[]`` Некоторые пользователи сети сделали такое сравнение в Интернете. Исходный текст находится на странице 212 книги. Он описывается следующим образом: Qt использует неявное совместное использование для всех контейнеров и многих других классов. Неявное совместное использование является гарантией Qt того, что данные, которые не нужно изменять, никогда не будут скопированы, чтобы чтобы сделать неявное совместное использование. Чтобы играть лучшую роль, вы можете принять два новых навыка программирования. Первая привычка - использовать функцию at () вместо оператора [] при выполнении доступа только для чтения к (непостоянному) вектору или списку, потому что контейнерный класс Qt не может определить, появится ли оператор [] в Левая часть присваивания остается правой. Он предполагает, что имеет место наихудший случай, и обеспечивает глубокое присваивание, в то время как функция at () не может появляться в левой части присваивания.
72. Если это диалоговая форма, вам необходимо разрешить выполнение других кодов после exec. Добавьте строку кода перед диалоговой формой exec, иначе сообщение формы будет заблокировано.
```cpp
QDialog dialog;
dialog.setWindowModality(Qt::WindowModal);
dialog.exec();
```
73. Чтобы безопасно удалить классы объектов Qt, настоятельно рекомендуется использовать deleteLater вместо delete, потому что deleteLater выберет выпускать его в нужное время, а delete освободит его немедленно, что может вызвать ошибку и сбой. Если вы хотите удалить коллекцию объектов партиями, вы можете использовать qDeleteAll, например qDeleteAll (btns);
74. В элементе управления QTableView, если вам нужно настроить кнопки столбцов, флажки, раскрывающиеся списки и другие режимы для отображения, вы можете использовать для этого настраиваемый делегат QItemDelegate. Если вам нужно отключить столбец, вы можете вернуться в настраиваемом Перегруженная функция createEditor 0 делегата в порядке. Элемент управления, соответствующий настраиваемому делегату, появляется при входе в состояние редактирования.Если вы хотите, чтобы он продолжал отображаться, вам нужно перегрузить функцию рисования, чтобы рисовать с помощью drawPrimitive или drawControl.
75. Ознакомьтесь с ``drawPrimitive, drawControl, drawItemText, drawItemPixmap`` и другими методами, соответствующими ``QApplication :: style ()``. В сочетании со свойством QStyleOption вы можете воспроизводить различные пользовательские комиссии, и вы можете напрямую использовать рисовальщик в функции рисования для выполнения различных Рисование, всевозможные классные таблицы, древовидные списки, выпадающие списки и т. д. обязательно взорвутся. Если четвертый параметр ``QApplication :: style () -> drawControl`` не установлен, нарисованный элемент управления не будет применять таблицу стилей.
76. В уме есть координаты, все - художник. Настоятельно рекомендуется, чтобы при обучении рисованию пользовательских элементов управления вы прочитали, попытались понять все функции в файле заголовка qpainter.h. Это включает в себя все встроенные рисунки интерфейсы Qt. Попробуйте соответствующие параметры еще раз, и вы обнаружите много новых миров, которые в определенной степени будут стимулировать ваш интерес к рисованию, точно так же, как волшебная кисть Ма Лян, верхом на лошади путешествовать по миру рисования кода.
77. 在В процессе использования setItemWidget или setCellWidget иногда обнаруживается, что элемент управления set не отображается в центре, а по умолчанию выровнен по левому краю и не будет автоматически растягиваться и заполняться. Для программистов, стремящихся к совершенству, это не очень красиво , у него есть окончательный вариант. Общий метод состоит в том, чтобы поместить этот элемент управления в макет виджета, а затем добавить виджет к элементу, это идеальное решение, и оно может объединять несколько элементов управления для создания сложных элементов управления.
```cpp
// Создание экземпляра элемента управления индикатора выполнения
QProgressBar *progress = new QProgressBar;
// Добавляем макет виджета, чтобы грамотно добиться центрирования
QWidget *widget = new QWidget;
QHBoxLayout *layout = new QHBoxLayout;
layout->setSpacing(0);
layout->setMargin(0);
layout->addWidget(progress);
widget->setLayout(layout);
ui->tableWidget->setCellWidget(0, 0, widget);
```
78. Во многих случаях необходимо четко нарисовать текст, когда известен цвет фона. В это время необходимо рассчитать соответствующий цвет текста.
```cpp
// Автоматически вычислить соответствующий цвет переднего плана в соответствии с цветом фона
double gray = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255;
QColor textColor = gray > 0.5 ? Qt::black : Qt::white;
```

79. Отключите перетаскивание столбца для QTableView или QTableWidget.
```cpp
#if (QT_VERSION <= QT_VERSION_CHECK(5,0,0))
    ui->tableView->horizontalHeader()->setResizeMode(0, QHeaderView::Fixed);
#else
    ui->tableView->horizontalHeader()->setSectionResizeMode(0, QHeaderView::Fixed);
#endif
```
80. От Qt4 до Qt5 некоторые методы устарели или устарели. Если вы хотите включить методы Qt4 в Qt5, такие как ``setMovable QHeadVew``, вы можете добавить строку в свой файл pro или pri:``DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0``
81. QColor в Qt идеально подходит для инкапсуляции цвета и поддерживает различные преобразования, такие как rgb, hsb, cmy, hsl, соответствующие toRgb, toHsv, toCmyk, toHsl, а также поддерживает настройки прозрачности, а значение цвета также может быть преобразовано в шестнадцатеричный формат отображать.
```cpp
QColor color(255, 0, 0, 100);
qDebug() << color.name() << color.name(QColor::HexArgb);
//Вывод #ff0000 #64ff0000
```
82. Тип QVariant чрезвычайно мощный и может быть назван универсальным типом. При хранении файлов конфигурации часто используется преобразование QVariant. QVariant по умолчанию поставляется с различными преобразованиями, такими как toString и toFloat, но этого недостаточно, например , иногда нужно переключаться с QVariant на QColor, но не предоставляет функцию toColor, на этот раз нам нужно использовать универсальный метод.
```cpp
if (variant.typeName() == "QColor") {
    QColor color = variant.value<QColor>();
    QFont font = variant.value<QFont>();
    QString nodeValue = color.name(QColor::HexArgb);
}
```
83. Для преобразования между QString и const char * в Qt лучше всего использовать toStdString (). C_str () вместо toLocal8Bit (). ConstData (). Например, если вы используете последнее в setProperty, китайская строка будет неверной , и английский нормальный
84. Механизм сигнальных слотов Qt очень мощный, и он также является одной из уникальных основных функций Qt. Иногда мы передаем сигналы во многие окна для обновления или обработки. Если существует много уровней окон, например, родительский класс формы A - это Form B, родительской формой B является форма C, форма C имеет дочернюю форму D, если сигнал формы A должен быть передан в форму D, проблема возникает, вы должны сначала пройти через форму B в окно Body C, которое может затем перейдите к форме D. В этом случае будет много соединений, связанных с различными сигналами, и управление будет беспорядочным. Вы можете рассмотреть возможность добавления глобального одноэлементного класса AppEvent, поместить сюда общедоступный сигнал, а затем сформировать A, соответствующий signal привязан к AppEvent, а форма D связывает сигнал AppEvent с соответствующей функцией слота, которая является чистой и аккуратной.
85. Меню QTextEdit, вызываемое правой кнопкой мыши по умолчанию, отображается на английском языке. Если вы хотите отображать текст на китайском языке, просто загрузите файл widgets.qm. Вы можете установить несколько файлов перевода в программе Qt без конфликтов.
86. В Qt есть сигнал переключения глобального фокуса focusChanged, который можно использовать как настраиваемый метод ввода. Контекст метода ввода установлен по умолчанию в Qt4. Например, при печати a.inputContext в основной функции будет отображаться значение. Этот установленный по умолчанию контекст метода ввода будет перехватывать два замечательных сигнала QEvent :: RequestSoftwareInputPanel и QEvent :: CloseSoftwareInputPanel, так что даже если вы установите глобальный фильтр событий, эти два сигнала все равно не распознаются.Вам нужно только выполнить a.setInputContext (0) в основной функции, что означает, что контекст метода ввода установки пуст. После Qt5.7 предоставляется встроенный метод ввода, который можно включить, добавив qputenv ("QT_IM_MODULE", QByteArray ("qtvirtualkeyboard")); в начале основной функции.
87. После Qt5.10 минимальная ширина столбца по умолчанию для элемента управления таблицей QTableWidget или QTableView изменена на 15, предыдущая версия - 0, поэтому в новой версии qt, если ширина столбца таблицы установлена ​​слишком маленькой, она будет не применяется. Наименьшая ширина столбца. Поэтому, если вы хотите установить меньшую ширину столбца, вам нужно сбросить ui-> tableView-> horizontalHeader () -> setMinimumSectionSize (0);
88. Некоторые нераскрытые черные технологии, которые нельзя использовать напрямую, встроены в исходный код Qt, которые скрыты в приватном соответствующем модуле, например, частные виджеты gui-private и т. Д., Такие как класс распаковки zip-файла QZipReader и Класс сжатия QZipWriter находится в модуле gui-private In, вам нужно ввести QT + = gui-private в pro, чтобы использовать его.
```cpp
#include "QtGui/private/qzipreader_p.h"
#include "QtGui/private/qzipwriter_p.h"
ZipReader reader(dirPath);
QString path("");
//Распаковать папку в текущий каталог
reader.extractAll(path);
//Имя папки
QZipReader::FileInfo fileInfo = reader.entryInfoAt(0);
//разархивировать файлы
QFile file(filePath);
file.open(QIODevice::WriteOnly);
file.write(reader.fileData(QString::fromLocal8Bit("%1").arg(filePath)));
file.close();
reader.close();

QZipWriter *writer = new QZipWriter(dirPath);
//Добавить папку
writer->addDirectory(unCompress);
//добавить файлы
QFile file(filePath);
file.open(QIODevice::ReadOnly);
writer->addFile(data, file.readAll());
file.close();
writer->close();
```
89. Теоретически и последовательный порт, и сеть, отправляющая и получающая данные, по умолчанию являются асинхронными. Операционная система автоматически планирует и не блокирует интерфейс вообще. Те, кто в Интернете говорят, что отправляемые и получаемые данные застревают в Основной поток интерфейса - это всего несколько яиц.Реальные затраты времени связаны с вычислениями и пост-расчетной обработкой, а не с отправкой и получением данных, как правило, не рекомендуется использовать потоки для обработки в некоторых небольших проектах по вычислению данных. требуют накладных расходов на планирование. Не бросайте все в потоки. Потоки не всемогущи. Только тогда, когда действительно необходимы некоторые трудоемкие операции, такие как кодирование и декодирование, их нужно переносить в обработку потоков.

90. Получение ширины и высоты элемента управления в конструкторе, вероятно, некорректно. Правильно получать их после того, как элемент управления отображается в первый раз. Правильные значения ширины и высоты устанавливаются после того, как элемент управления отображается в первый раз. Помните, что после первого отображения, а не после запуска конструктора или программы, если некоторые элементы управления контейнера, такие как элементы управления на странице, которые не отображаются в QTabWidget после запуска программы, вы можете получить неверную ширину и высоту. • Надежный метод - получить его после первого отображения.
91. Обработка базы данных обычно рекомендуется в основном потоке. Если вам нужно сделать это в других потоках, вы должны не забыть открыть базу данных в этом потоке, то есть использовать базу данных в этом потоке, чтобы открыть ее в этом потоке. Вы не может открыть базу данных в основном потоке и выполнить sql в подпоточном потоке, очень вероятно, что возникла проблема.
92. Новая версия класса QTcpServer может не входить в функцию incomingConnection в 64-битной версии Qt. Это связано с тем, что параметр функции incomingConnection, соответствующий Qt5, был изменен. Предыдущий int был изменен на qintptr. Есть преимущество в изменении в qintptr. В 32-битной версии это автоматически quint32 в 64-битной и quint64 на 64-битной. Если параметр, который должен быть записан в Qt5, имеет значение int, проблем нет в 32-битной и 64-битной версиях, поэтому, чтобы быть совместимым с Qt4 и Qt5, он должен быть другим параметром записи.
```cpp
#if (QT_VERSION > QT_VERSION_CHECK(5,0,0))
    void incomingConnection(qintptr handle);
#else
    void incomingConnection(int handle);
#endif
```
93. Qt поддерживает все элементы управления интерфейсом, такие как QPushButton и QLineEdit, для автоматического связывания сигнального слота on_control name_signal (параметр), такого как сигнал нажатия кнопки on_pushButton_clicked (), а затем напрямую реализует функцию слота.
94. Поскольку элемент управления QWebEngineView использует opengl, на некоторых компьютерах драйвер opengl может быть слишком низким, что может вызвать мерцание экрана или различные странные проблемы. Например, правая кнопка мыши не работает в случае showfullscreen, а программный рендеринг opengl требует быть включенным в основной функции.
```cpp
#if (QT_VERSION > QT_VERSION_CHECK(5,4,0))
    //Могут использоваться следующие два метода, Qt по умолчанию использует AA_UseDesktopOpenGL
    QCoreApplication::setAttribute(Qt::AA_UseOpenGLES);
    //QCoreApplication::setAttribute(Qt::AA_UseSoftwareOpenGL);
#endif
    QApplication a(argc, argv);
```
Другой способ решить проблему - это то, что элемент управления полноэкранным + QWebEngineView вызовет ошибку, из-за которой контекстное меню не может появиться во всплывающем окне, и его необходимо переместить на один пиксель вверх.
```cpp
QRect rect = qApp->desktop()->geometry();
rect.setY(-1);
rect.setHeight(rect.height());
this->setGeometry(rect);
```
95. QStyle Есть много встроенных методов, которые очень полезны, например, точное получение значения ползунка, на котором нажата мышь.
```cpp
QStyle::sliderValueFromPosition(minimum(), maximum(), event->x(), width());
```
96. При использовании QFile для чтения и записи файлов рекомендуется использовать QTextStream для чтения и записи файлов. Скорость намного выше, и в основном будет улучшение на 30%. Чем больше файл, тем больше разница в производительности.
```cpp
// Загружаем из файла таблицу сравнения атрибутов на английском и китайском языках
QFile file(":/propertyname.txt");
if (file.open(QFile::ReadOnly)) {
    // Скорость чтения метода QTextStream как минимум на 30% выше
#if 0
    while(!file.atEnd()) {
        QString line = file.readLine();
        appendName(line);
    }
#else
    QTextStream in(&file);
    while (!in.atEnd()) {
        QString line = in.readLine();
        appendName(line);
    }
#endif
    file.close();
}
```
97. Использование QFile.readAll () для чтения файлов QSS по умолчанию в формате ANSI и не поддерживает UTF 8. Если вы откроете файл qss в QtCreator для редактирования и сохранения, вероятно, что qss не будет иметь никакого эффекта после загрузки.
```cpp
void frmMain::initStyle()
{
    // Загружаем таблицу стилей
    QString qss;
    //QFile file(":/qss/psblack.css");
    //QFile file(":/qss/flatwhite.css");
    QFile file(":/qss/lightblue.css");
    if (file.open(QFile::ReadOnly)) {
#if 1
        // Использование QTextStream для чтения файлов стилей не требует различения кодировки файла. Bom тоже в порядке
        QStringList list;
        QTextStream in(&file);
        //in.setCodec("utf-8");
        while (!in.atEnd()) {
            QString line;
            in >> line;
            list << line;
        }

        qss = list.join("\n");
#else
        // Использование readAll для чтения формата ANSI поддерживается по умолчанию. Если вы случайно откроете его с помощью создателя и отредактируете, возможно, вы не сможете его открыть.
        qss = QLatin1String(file.readAll());
#endif
        QString paletteColor = qss.mid(20, 7);
        qApp->setPalette(QPalette(QColor(paletteColor)));
        qApp->setStyleSheet(qss);
        file.close();
    }
}
```
98. QString имеет множество встроенных функций преобразования, например, вы можете вызвать toDouble для преобразования двойных данных, но когда вы закончите преобразование и распечатаете его, вы обнаружите, что точность меньше, и осталось только три цифры. исходные данные по-прежнему имеют полную точность, но при печати они оптимизируются до трех цифр.Если вы хотите обеспечить полную точность, вы можете вызвать функцию qSetRealNumberPrecision, чтобы установить количество цифр точности.
```cpp
QString s1, s2;
s1 = "666.5567124";
s2.setNum(888.5632123, 'f', 7);
qDebug() << qSetRealNumberPrecision(10) << s1.toDouble() << s2.toDouble();
```

99. При использовании QScriptValueIterator для анализа данных вы обнаружите, что всегда будет еще одно содержимое узла, а содержимое пустое, если вам нужно его пропустить, добавьте строку кода.
```cpp
while (it.hasNext()) {
    it.next();    
    if (it.flags() & QScriptValue::SkipInEnumeration)      
       continue;     
    qDebug() << it.name();
}
```
100. setPixmap то наихудший текстурный метод. Обычно он используется только для простых и нечастых текстур. Для рисования часто рекомендуется использовать Painter. По умолчанию используется двойная буферизация. Он отрисовывается с помощью opengl в расширенных точках и использует графический процессор.
101. Если вам нужно не перерисовывать форму при изменении размера, просто установите свойства this->setAttribute(Qt::WA_StaticContents, true); Это поможет избежать перерисовки уже отображаемой области.
102. В программе по умолчанию после получения фокуса будет виртуальная граница.Если вы посмотрите на нее и почувствуете дискомфорт, вы можете удалить ее и установить стиль.：setStyleSheet("*{outline:0px;}");
103. Некоторые часто используемые настройки элементов управления таблиц Qt инкапсулированы. QTableWidget наследуется от QTableView, поэтому следующая функция поддерживает передачу в QTableWidget.
```cpp
void QUIHelper::initTableView(QTableView *tableView, int rowHeight, bool headVisible, bool edit)
{
    //Чередование цветов в нечетных и четных рядах
    tableView->setAlternatingRowColors(false);
    //Виден ли вертикальный заголовок
    tableView->verticalHeader()->setVisible(headVisible);
    //选中一行表头是否加粗
    tableView->horizontalHeader()->setHighlightSections(false);
    //Последняя строка тянется до заполнения
    tableView->horizontalHeader()->setStretchLastSection(true);
    //Минимальная ширина заголовка строки
    tableView->horizontalHeader()->setMinimumSectionSize(0);
    //Максимальная высота заголовка строки
    tableView->horizontalHeader()->setMaximumHeight(rowHeight);
    //Высота строки по умолчанию
    tableView->verticalHeader()->setDefaultSectionSize(rowHeight);
    //Выберите строку в целом, когда она выбрана
    tableView->setSelectionBehavior(QAbstractItemView::SelectRows);
    //Разрешить выбрать только один
    tableView->setSelectionMode(QAbstractItemView::SingleSelection);

    //Заголовок не кликабельный
#if (QT_VERSION > QT_VERSION_CHECK(5,0,0))
    tableView->horizontalHeader()->setSectionsClickable(false);
#else
    tableView->horizontalHeader()->setClickable(false);
#endif

    //Нажмите мышку, чтобы войти в режим редактирования
    if (edit) {
        tableView->setEditTriggers(QAbstractItemView::CurrentChanged | QAbstractItemView::DoubleClicked);
    } else {
        tableView->setEditTriggers(QAbstractItemView::NoEditTriggers);
    }
}
```
104. В некоторых крупных проектах многие подпроекты могут быть вложенными. Иногда, когда подпроекты зависят от других подпроектов, например, некоторые подпроекты используются для создания динамических библиотек, а некоторые подпроекты полагаются на эту динамическую библиотеку. для компиляции, необходимо скомпилировать подпроекты по порядку или задать правила зависимости.
```cpp
TEMPLATE = subdirs
# Установить заказанные параметры будут по очереди компилироваться в будущем projA projB projC
CONFIG  += ordered
SUBDIRS += projA
SUBDIRS += projB
SUBDIRS += projC
# Вы также можете указать зависимость проекта, установив зависимости. Например, укажите projB, чтобы он зависел от projA ниже
projB.depends = projA
projC.depends = projA
projD.depends = projC
```
105. Инструкции по выбору компилятора MSVC
- Если это 32-битный Qt, компилятор выбирает начало x86
- Если это 64-битный Qt, компилятор выбирает начало amd64
- В частности, это зависит от установленной версии комплекта сборки Qt, разрядности системы и архитектуры целевой операционной платформы.
- Как правило, современные компьютеры по умолчанию в основном 64-битные, просто выберите amd64.
- Если пользователю нужна 32-битная совместимая система, рекомендуется выбрать 32-битную Qt, чтобы она могла работать в 32-битных или 64-битных системах.
- Г-н Чжугэ добавил: x86 / x64 компилируются и запускаются в одной среде, и нет или. Подчеркнутый - это кросс-компиляция, спереди - среда компиляции, а сзади - среда выполнения.

| Имя | Описание  |
| ------ | ------ |
|x86|32/64 Составлено на 32/64 Беги на битовой системе|
|x86_amd64|32/64位系统上编译在64位系统上运行|
|x86_arm|32/64位系统上编译在arm系统上运行|
|amd64|64位系统上编译在64位系统上运行|
|amd64_x86|64位系统上编译在32/64位系统上运行|
|amd64_arm|64位系统上编译在arm系统上运行|

106. Много раз при использовании QDialog вы обнаруживаете, что сообщение заблокировано, и иногда мы надеемся, что некоторые сообщения в фоновом режиме будут продолжать работать и не будут завершены. В настоящее время нам необходимо выполнить настройку.
```cpp
QDialog dialog;
dialog.setWindowModality(Qt::WindowModal);
```
107. Многие новички или даже люди с многолетним опытом работы глубоко не понимают и злоупотребляют многопоточностью, особенно в последовательном порте и сетевом взаимодействии, все бросается в многопоточность. Как только интерфейсная карта встречается, данные будут быть отправленным и полученным. Все делается в многопоточном режиме, но в большинстве случаев это совершенно бесполезно, потому что не обнаружена первопричина проблемы.
- Если вы не используете функцию `` wait *** '', большая часть интерфейсных карт находится в процессе обработки и отображения данных. Это должно занять много времени;
- Существует также кривая полученных данных. Если они слишком частые или интервал слишком короткий, это определенно вызовет сильную нагрузку на пользовательский интерфейс. Лучший способ - решить, как не рисовать пользовательский интерфейс часто, например объединение объединенных данных воедино;
- Если карта вызвана отрисовкой пользовательского интерфейса, то многопоточность бесполезна, поскольку пользовательский интерфейс может находиться только в основном потоке;
- Передача и прием данных через последовательный порт и сеть по умолчанию асинхронны и планируются операционной системой. Если обработка данных сложная и объем данных велик, вам нужно выполнить обработку данных в нескольких потоки;
- Если нет строгих требований к синхронизации данных, нет необходимости вызывать такие функции, как wait *** для немедленной отправки и получения данных.В реальных требованиях большинства сценариев приложений на самом деле достаточно, чтобы отправлять и получать данные асинхронно;
- В сценариях со строгими требованиями к синхронизации данных лучше размещать несколько потоков, иначе ваше ``wait ***`` застрянет там;
- Многопоточность должна занимать системные ресурсы. Теоретически, если количество потоков превышает количество ядер ЦП, на самом деле многопоточное планирование может занять больше времени. Вы должны взвесить все «за» и «против» во время использования;
- Опять же, не ожидайте, что сетевое взаимодействие Qt будет поддерживать высокий уровень параллелизма. До 1000 может работать нормально, и все будет хорошо. Как правило, рекомендуется количество подключений в пределах 500. Для большого количества требований с высоким уровнем параллелизма используйте сторонние библиотеки, такие как swoole.

108. Во встроенном Linux, если установлено окно без полей и в нем есть текстовое поле, обнаруживается, что фокус не может быть сгенерирован для ввода, и окно должно быть активно активировано в это время.
```cpp
//Установленное таким образом окно без полей не может фокусироваться на встроенных устройствах.
setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint | Qt::X11BypassWindowManagerHint);

//Необходимо активировать форму после показа
w->show();
w->activateWindow();
```
109. QString из replace Функция изменит исходную строку. Помните, она также изменит исходную строку при возврате замененной новой строки, моя дорогая!
110. Связанные эффекты класса QGraphicsEffect очень ошеломляющие и могут достигать многих эффектов, таких как прозрачность, градиенты, тени и т. Д., Но этот класс очень загружает процессор, и обычно не рекомендуется использовать его, если он не особенно необходим. 
111. Косая черта в пути к файлу отличается на разных платформах. Например, в Linux-системах обычно используется /, но в Windows это \\ две обратные косые черты. Сама программа Qt поддерживает как win, так и linux. / Путь косой черты, но некоторые сторонние библиотеки могут нуждаться в преобразовании в путь соответствующей системы, что требует использования преобразования косой черты.Конечно, Qt имеет встроенные методы класса.
```cpp
QString path = "C:/temp/test.txt";
path = QDir::toNativeSeparators(path);
//Вывод C:\\temp\\test.txt

QString path = "C:\\temp\\test.txt";
path = QDir::toNativeSeparators(path);
//Вывод C:/temp/test.txt
```
112. Умное использование QMetaObject::invokeMethod Метод позволяет достичь многих эффектов, включая синхронное и асинхронное выполнение, в значительной степени решить проблему межпотоковой обработки сигнальных слотов. Например, в обратном вызове есть сценарий приложения, который нужно вызывать асинхронно. publicФункция, если она вызывается напрямую, будет признана неудачной. В это время вам нужно использовать QMetaObject::invokeMethod(obj, "fun", Qt::QueuedConnection); Просто иди этим путем.
- invokeMethod Функция имеет много перегруженных параметров, вы можете передать возвращаемое значение и параметры метода выполнения.
- invokeMethod Функция не только поддерживает функции слотов, но также поддерживает сигналы, и на самом деле это потокобезопасно, и ее можно с уверенностью использовать в потоках, здорово!
- Тест показал, что могут быть выполнены только методы, идентифицированные сигналами или слотами.
- По умолчанию функции из частных (защищенных / общедоступных) слотов могут выполняться, но функции из частных (защищенных / общедоступных) не могут выполняться.
-Г-н Мао добавил: Предпосылка должна быть функцией, отмеченной слотами или сигналами. Незаметная функция отсутствует в метаинформации и не может быть найдена. После выполнения будет предложено Нет такого метода.
- 2021-11-06Дополнение: если вы хотите выполнить функцию под приватным (защищенным / общедоступным), вам нужно добавить ключевое слово Q_INVOKABLE перед функцией.Я снова выучил его сегодня и должен добавить куриные окорочка.
- Фактически, если посмотреть на это с этой точки зрения, может быть выполнена любая функция метода, которая выходит за пределы частного (защищенного / общедоступного). Это эквивалентно тому, что частная функция класса может быть выполнена с помощью invokeMethod, если она изменена с помощью ключевое слово Q_INVOKABLE. Щелкните.
```cpp
//Заголовочный файл объявляет функции сигналов и слотов.
signals:
    void sig_test(int type,double value);
private slots:
    void slot_test(int type, double value);
private:
    Q_INVOKABLE void fun_test(int type, double value);

//Слот сигнала, связанный с конструктором
connect(this, SIGNAL(sig_test(int, double)), this, SLOT(slot_test(int, double)));

//Нажмите кнопку, чтобы запустить сигнал и слот, вот пример сигнального слота одновременно
void MainWindow::on_pushButton_clicked()
{
    QMetaObject::invokeMethod(this, "sig_test", Q_ARG(int, 66), Q_ARG(double, 66.66));
    QMetaObject::invokeMethod(this, "slot_test", Q_ARG(int, 88), Q_ARG(double, 88.88));
    QMetaObject::invokeMethod(this, "fun_test", Q_ARG(int, 99), Q_ARG(double, 99.99));
}

//Напечатаю 66 66.66、88 88.88
void MainWindow::slot_test(int type, double value)
{
    qDebug() << type << value;
}

//Напечатаю 99.99
void MainWindow::fun_test(int type, double value)
{
    qDebug() << type << value;
}
```

113. Сигнал в Qt5 является общедоступным и может быть испущен прямо там, где это необходимо. В Qt4 сигнал защищен и не может использоваться напрямую. Вам необходимо определить общедоступную функцию для испускания. 

114. Начиная с версии Qt5.15, официальный представитель больше не предоставляет установочные пакеты, только исходный код, который вы можете скомпилировать самостоятельно или установить онлайн. По оценкам, каждый раз компилировать различные версии слишком сложно. Это больше для сбора пользователей такую ​​информацию, как онлайн-установка. На более позднем этапе коммерциализация может постепенно увеличиваться.
115. Иногда нам нужно судить, есть ли модуль в текущей версии Qt, о котором можно судить с помощью qtHaveModule (недавно введенное решение в Qt5). Если вы хотите определить, есть ли модуль, добавленный QT + = в ваш проект, вы можно использовать содержит, чтобы судить.

```cpp
qtHaveModule(webenginewidgets) {
message("Текущая библиотека Qt найдена webenginewidgets Модуль")
}

!qtHaveModule(webkit) {
message("Текущая библиотека Qt не находит модуль webkit")
}

contains(QT, network) {
message("Текущий проект представил сетевой модуль")
}

!contains(QT, widgets) {
message("В предыдущем проекте модуль виджетов не использовался.")
}
```
116. c++11 Введен исходный формат строки, и пользователи избегают добавления в строку escape-символов \, которые можно использовать для представления строк json и других сценариев.
```cpp
QString s1 = R"(test\001.jpg)";
s1.replace("\\", "#");
qDebug()<< s1;
//результат test#001.jpg
```
117. Рекомендуется для печати информации на Android qInfo() Вместо qDebug() ，qInfo() Только иметь эффект。

118. Точность таймера Qt по умолчанию недостаточно высока (например, сценарий приложения - сохранить запись или файл за 1 минуту. Когда вы используете таймер по умолчанию, вы обнаружите, что иногда он составляет 60 секунд, а некоторые 59 секунд являются случайными. требует заказчик Это требует установки точности. Конечно, для большинства проектов, которые нам не нужны, таймеры очень высокой точности не требуются. Ведь чем выше точность, тем больше занятых системных ресурсов). Если вам нужно установить более высокую точность, вы можете установить его. ``setTimerType(Qt::PreciseTimer)``。Qt имеет два типа обработки таймера, один - это класс ``QTimer``, а другой - встроенное событие ``timeevent`` класса ``QObject``. Если таймер класса ``QObject`` должен быть установлен, вызовите его ``startTimer(interval, Qt::PreciseTimer);``
- Qt::PreciseTimer Точный таймер, старайтесь поддерживать точность до миллисекунды.
- Qt::CoarseTimer Грубые таймеры, старайтесь держать точность в пределах 5% от необходимого временного интервала.
- Qt::VeryCoarseTimer Очень грубый таймер, сохраняет только полную секундную точность.
- Независимо от того, насколько высока точность, она также зависит от соответствующего прерывания операционной системы.Предполагая, что прерывание занимает 5 мс, точность таймера не может быть выше 5 мс.
119. ``QGraphicsEffect`` Связанные классы очень интенсивно загружают процессор и даже конфликтуют и мешают работе в определенных местах при рисовании. Как правило, не рекомендуется использовать его. Рекомендуется использовать только в небольших количествах и в местах, где рисование не часто запускается.
120. Используйте ``QSettings`` для настройки реестра, если вы не работаете с правами администратора, он напечатает ``QSettings: не удалось установить подраздел «xxx» (Доступ запрещен.)``, Вам нужно вручную щелкнуть правой кнопкой мыши, чтобы запустить его от имени администратора.
121. QLineEdit Помимо простого текстового поля, его также можно использовать для многих специальных целей обработки.
- Ввод с ограничениями можно ввести только по IP-адресу.
- Чтобы ограничить диапазон ввода, настоятельно рекомендуется использовать для обработки регулярные выражения ``QRegExpValidator``.
```cpp
//Ограничение ввода в выражении
QString str = "\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b";
ui->lineEdit->setValidator(new QRegExpValidator(QRegExp(str)));
//Для заполнителя
ui->lineEdit->setInputMask("000.000.000.000");

#if 0
//В следующем коде не удается установить предел диапазона чисел с плавающей запятой.
ui->lineEdit->setValidator(new QDoubleValidator(20, 50, 1));
#else
//Следующий код успешно устанавливает предел диапазона чисел с плавающей запятой.
QDoubleValidator *validator = new QDoubleValidator(20, 50, 1);
validator->setNotation(QDoubleValidator::StandardNotation);
ui->lineEdit->setValidator(validator);
#endif
//Следующий код успешно устанавливает предел целочисленного диапазона.
ui->lineEdit->setValidator(new QIntValidator(10, 120));

//На самом деле, в приведенном выше коде много недостатков, он может ограничивать только ввод десятичных знаков, а диапазон значений установить невозможно, так что блять
//Нужен всемогущий офигенный QRegExpValidator

//Ограничьте диапазон ввода чисел с плавающей запятой до [-180,180]
QRegExp regexp("^-?(180|1?[0-7]?\\d(\\.\\d+)?)$");
//Ограничьте диапазон ввода чисел с плавающей запятой до [-90,90] и до 4 знаков после запятой.
QRegExp regexp("^-?(90|[1-8]?\\d(\\.\\d{1,4})?)$");
QRegExpValidator *validator = new QRegExpValidator(regexp, this);
ui->lineEdit->setValidator(validator);
```
122. В элементах управления, унаследованных от QAbstractItemView, таких как QTableView и QTableWidget, если текст превышает соответствующий itemЕсли вы хотите быстро отобразить весь текст, вы можете дважды щелкнуть между разделительной линией этого столбца и следующим столбцом, и максимальная ширина будет автоматически отображаться адаптивно.Если это Qt5.14 или новее, вы найдете что правила вычисления для отображения многоточия изменились. Если это строка на английском языке, начинающаяся с rtsp, http и т. д., с той же шириной столбца, многоточие будет отображаться заранее, например, строка rtmp://58.200.131.2:1935/livetv/cctv1，会显示成 rtmp://...  ，В старой версии Qt он будет отображаться как rtmp://58.200.131... ，Часто мы не хотим видеть надоедливое многоточие, мы можем настроить его на отмену.
```cpp
//Отменить перенос слов
tableView->setWordWrap(false);
//Не отображать многоточие за текстом
tableView->setTextElideMode(Qt::ElideNone);
```
123. QVideoWidget При воспроизведении видео экран может мерцать.Окно для воспроизведения видео требует установки атрибута.
```cpp
QVideoWidget *videoWidget = new QVideoWidget;
videoWidget->setAttribute(Qt::WA_OpaquePaintEvent);
```
123. Qt bug Их тысячи, не нужно суетиться, и в основном вы с ними не сталкиваетесь. Большинство из них представляют собой особые экстремальные ситуации и конкретные сценарии применения, и вы даже можете столкнуться с некоторыми debug Может release Сообщить об ошибке ，Некоторые выпуски могут отлаживать, но сообщать об ошибке. Самое удивительное, что отладка сначала сообщает об ошибке, затем выпуск нормальный, а затем отладка снова нормальная. Вам необходимо активировать его вместе с выпуском! Путь к изучению программирования изначально был ухабистым, продолжайте заполнять пробелы и старайтесь их избегать! Часто многие кажущиеся ямы на самом деле вызваны невниманием к деталям.
124.  Сортировка по умолчанию в представлении Qt сортируется в соответствии с ASCII строки. Если это IP-адрес, 192.168.1.117 будет ранжироваться до 192.168.1.2. Если вы хотите избежать этой ситуации, один из способов - взять адрес в конце и превратить его в целые числа все больше и больше. Недостатком является то, что они останавливаются, когда пересекают сегмент сети, и 192.168.2.65 появляется перед 192.168.1.70. Конечный метод - преобразовать IP-адрес в целое число и затем сравните размер.
```cpp
QString QUIHelper::ipv4IntToString(quint32 ip)
{
    QString result = QString("%1.%2.%3.%4").arg((ip >> 24) & 0xFF).arg((ip >> 16) & 0xFF).arg((ip >> 8) & 0xFF).arg(ip & 0xFF);
    return result;
}

quint32 QUIHelper::ipv4StringToInt(const QString &ip)
{
    int result = 0;
    if (isIP(ip)) {
        QStringList list = ip.split(".");
        int ip0 = list.at(0).toInt();
        int ip1 = list.at(1).toInt();
        int ip2 = list.at(2).toInt();
        int ip3 = list.at(3).toInt();
        result = ip3 | ip2 << 8 | ip1 << 16 | ip0 << 24;
    }
    return result;
}
```
125.Если вы установите фоновое изображение непосредственно в основной форме ``QWidget`` с помощью ``qss``, предварительный просмотр будет виден, и операция не будет иметь никакого эффекта. Вам нужно поместить другой виджет на основной виджет и установить изображение qss на новый виджет. Форма ``Dialog`` или ``QMainWindow`` поддерживает прямую настройку фонового изображения ``qss``, а предварительный просмотр и выполняемые эффекты согласованы.
126. Qt предоставляет механизм qDebug для прямого вывода информации о печати.Это компенсирует недостатки отладки QtCreator и легко подключается к ловушке журнала, так что запланированная информация о печати выводится в файл журнала во время работы на месте. не требуется на стадии разработки. Видя кучу печатной информации, самый глупый способ - это закомментировать qdebug построчно. Фактически, вы можете добавить строку непосредственно в pro, чтобы отключить вывод qdebug для всего проекта .
```cpp
# Отключить вывод на печать qdebug
DEFINES += QT_NO_DEBUG_OUTPUT
```

127.После использования ключевого слова QT_NO_DEBUG_OUTPUT для отключения всей информации для печати вы можете сэкономить много накладных расходов. Иногда вы хотите видеть информацию для печати в очень немногих местах после того, как вы отключили информацию для печати. ​​Что мне делать? Фактически, вывод qdebug отключен QT_NO_DEBUG_OUTPUT, Qt также имеет несколько другой информации для печати, такой как qInfo, qWarning, qCritical, на них это не влияет, то есть хорошо использовать qInfo для вывода информации в очень немногих местах, которые нужно распечатать. Особое примечание: после того, как qFatal напечатает информацию, программа автоматически завершится.
```cpp
qDebug() << "qDebug";
qInfo() << "qInfo";
qWarning() << "qWarning";
qCritical() << "qCritical";

qDebug("qDebug");
qWarning("qWarning");
qCritical("qCritical");
```
128. Файл Pro Qt может добавлять различные обработки, чтобы сделать конфигурацию более удобной, например, указание пути к выходному файлу и т. Д., Так что не все они будут просматриваться во множестве временных файлов, сгенерированных компиляцией.
```cpp
# Отключить вывод на печать qdebug
DEFINES     += QT_NO_DEBUG_OUTPUT

# Пользовательские переменные определения могут использоваться на протяжении всего проекта
#pro О файле можно судить так contains(DEFINES, videovlc) {}
#О кодовом файле можно судить так #ifdef videovlc
DEFINES     += videovlc1 videoffmpeg

# Отключить предупреждение о компиляции
CONFIG      += warn_off

# Укажите файлы, сгенерированные компиляцией, во временную директорию и сохраните их в разных категориях
MOC_DIR     = temp/moc
RCC_DIR     = temp/rcc
UI_DIR      = temp/ui
OBJECTS_DIR = temp/obj

# Указать скомпилированный исполняемый файл в директорию bin
DESTDIR     = bin
```
129. Qt также сделал много инкапсуляции сообщений на уровне операционной системы, которые могут быть обработаны напрямую (если вам нужно перехватить обработку, вам нужно использовать API соответствующей операционной системы, например, хуки мыши и клавиатуры), такие как спящий режим и пробуждение системы для некоторой обработки.
```cpp
//Заголовочный файл основной формы
protected:
    bool nativeEvent(const QByteArray &eventType, void *message, long *result);
#ifdef Q_OS_WIN
    bool winEvent(MSG *message, long *result);
#endif

//Функция реализации основной формы
#ifdef Q_OS_WIN
#include "Windows.h"
#endif

bool frmMain::nativeEvent(const QByteArray &eventType, void *message, long *result)
{
    if (eventType == "windows_generic_MSG") {
#ifdef Q_OS_WIN
        MSG *msg = static_cast<MSG *>(message);
        //qDebug() << TIMEMS << msg->message;
        if (msg->wParam == PBT_APMSUSPEND && msg->message == WM_POWERBROADCAST) {
            //Автоматически сворачивать, когда система находится в спящем режиме, чтобы избежать возможных проблем с программой
            this->showMinimized();
        } else if (msg->wParam == PBT_APMRESUMEAUTOMATIC) {
            //Автоматически открывается после пробуждения от сна
            this->showNormal();
        }
#endif
    } else if (eventType == "NSEvent") {
#ifdef Q_OS_MACOS
#endif
    }
    return false;
}

#ifdef Q_OS_WIN
bool frmMain::winEvent(MSG *message, long *result)
{
    return nativeEvent("windows_generic_MSG", message, result);
}
#endif
```

130. Файл конфигурации управления проектами Qt pro может также добавлять различные операции и конфигурации до и после компиляции, в основном через QMAKE_POST_LINK и ``QMAKE_PRE_LINK``. Подробные инструкции по функциям и методам записи, которые они поддерживают, вы можете найти в справке по функциям qmake в справке ``QtCreator``.
- QMAKE_PRE_LINK    Указывает содержимое выполнения перед компиляцией
- QMAKE_POST_LINK   Указывает содержимое выполнения после компиляции
```cpp
srcFile1 = $$PWD/1.txt
srcFile2 = $$PWD/2.txt
dstDir = $$PWD/../bin
#windows Преобразование косой черты пути в других системах не требуется
srcFile1 = $$replace(srcFile1, /, \\);
srcFile2 = $$replace(srcFile2, /, \\);
dstDir = $$replace(dstDir, /, \\);

#Выполните копирование перед компиляцией. Несколько копий можно разделить символом &&.
QMAKE_PRE_LINK += copy /Y $$srcFile1 $$dstDir && copy /Y $$srcFile2 $$dstDir
#Выполнить копию после компиляции, несколько копий могут быть разделены символом &&
QMAKE_POST_LINK += copy /Y $$srcFile1 $$dstDir && copy /Y $$srcFile2 $$dstDir
```
131. В новой версии Qt часто появляются некоторые обновления файла заголовка. Например, при использовании QPainter для рисования раньше не нужно включать дополнительные файлы заголовков ``QPainterPath``. Начиная с версии 5.15, необходимо отображать активное введение ``#include "qpainterpath.h" ``.

132. Выпущен Qt 6.0, который представляет собой относительно большую модифицированную версию. Многие базовые классы или компоненты помещены в отдельный пакет с исходным кодом и должны быть загружены и скомпилированы с официального сайта. По умолчанию интеграция в каталог разработки не предусмотрена. . Требуются ручная компиляция и интеграция. Например, QRegExp, QTextCodec, вам необходимо скомпилировать и интегрировать профессиональный файл QT + = core5compat, прежде чем вы сможете его использовать. Конкретные инструкции приведены в https://doc.qt.io/qt-6/qtcore5-index.html。
133. qDebug При выводе информации о печати escape-символы будут полностью напечатаны по умолчанию, например: \\ \ "\ t \ n" и т. Д., Поэтому, когда вы обнаружите, что после того, как вы установили escape-символ, печать действительно перед escape-символом, что сбивает с толку. На самом деле, qdebug выводит все типы символов для облегчения отладки. Бесспорно, что много раз мы были чрезвычайно рады пользоваться различными удобствами различных колес, предлагаемых Qt, но иногда, если вы не обращаете внимания, эти удобства могут вас обмануть. Все, что вам нужно сделать, это держать глаза открытыми, всегда быть осторожными и шаг за шагом изучать настоящий код.
```cpp
QString s1 = R"(\:device0)";
//TNND Что на самом деле вывод \\:device0
qDebug() << s1;
//Наконец-то правильный результат на этот раз \:device0
qDebug().noquote() << s1;
```
134. У многих людей возникают вопросы о том, почему qss не может управлять стилем веб-страниц в элементах управления браузера. Если вы задумаетесь, то поймете, что этим элементом управляет html css, и это не имеет ничего общего с Qt, поэтому вы можете вообще не контролирую.Чтобы установить стиль полосы прокрутки, вы можете установить стиль в коде веб-страницы.
```cpp
<style type="text/css">
  ::-webkit-scrollbar{width:0.8em;}
  ::-webkit-scrollbar-track{background:rgb(241,241,241);}
  ::-webkit-scrollbar-thumb{background:rgb(188,188,188);}
</style>
```
135. Файл конфигурации Qt ini по умолчанию не поддерживает прямое чтение и запись на китайском языке. Вам необходимо вручную установить формат кодировки. Настоятельно рекомендуется использовать кодировку utf-8, включая файлы кода.
```cpp
// После установки кода содержимое файла конфигурации выглядит следующим образом: Компания = Шанхайский научно-исследовательский центр Интернета вещей
//Если кодировка не задана, содержимое файла конфигурации будет Company=\xe4\xb8\x8a\xe6\xb5\xb7\xe7\x89\xa9\xe8\x81\x94\xe7\xbd\x91\xe6\x8a\x80\xe6\x9c\xaf\xe7\xa0\x94\xe7\xa9\xb6\xe4\xb8\xad\xe5\xbf\x83
void App::readConfig()
{
    QSettings set(App::ConfigFile, QSettings::IniFormat);
    set.setIniCodec("utf-8");

    set.beginGroup("AppConfig1");
    App::Company = set.value("Company", App::Company).toString();
    set.endGroup();
}
void App::writeConfig()
{
    QSettings set(App::ConfigFile, QSettings::IniFormat);
    set.setIniCodec("utf-8");

    set.beginGroup("AppConfig1");
    set.setValue("Company", App::Company);
    set.endGroup();
}
```
136. При использовании Qt для разработки Android вы столкнетесь с проблемами с разрешениями. Ранние версии Android могут напрямую добавлять необходимые разрешения через файл конфигурации AndroidManifest.xml, так что при установке приложения оно будет подсказывать пользователю, какие разрешения необходимы приложению. разрешите пользователю согласиться. Версия Android была изменена на динамические разрешения. Когда приложение запущено, появится всплывающее окно, позволяющее пользователю подтвердить, что у пользователя есть разрешения. Qt поддерживает эту стратегию и имеет встроенный метод динамического обращения за разрешениями. QtAndroid::requestPermissionsSync。
```cpp
//Динамически устанавливаемые разрешения
bool checkPermission(const QString &permission)
{
#ifdef Q_OS_ANDROID
#if (QT_VERSION >= QT_VERSION_CHECK(5, 10, 0))
    QtAndroid::PermissionResult result = QtAndroid::checkPermission(permission);
    if (result == QtAndroid::PermissionResult::Denied) {
        QtAndroid::requestPermissionsSync(QStringList() << permission);
        result = QtAndroid::checkPermission(permission);
        if (result == QtAndroid::PermissionResult::Denied) {
            return false;
        }
    }
#endif
#endif
    return true;
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
   
    //Просить разрешения
    checkPermission("android.permission.READ_EXTERNAL_STORAGE");
    checkPermission("android.permission.WRITE_EXTERNAL_STORAGE");   

    return a.exec();
}
```

137. Qt перезагружает qDebug для вывода настроенной информации.
```cpp
struct FunctionInfo {
    QString function;
    QString name;
    QString groupEnabled;
    QString action;
    QString group;

    friend QDebug operator << (QDebug debug, const FunctionInfo &functionInfo) {
        QString info = QString("Функция:% 1 Имя:% 2 Включить:% 3 Метод:% 4 Группа:% 5")
                       .arg(functionInfo.function).arg(functionInfo.name).arg(functionInfo.groupEnabled)
                       .arg(functionInfo.action).arg(functionInfo.group);
        debug << info;
        return debug;
    }
};
```
138. Адаптивный метод обработки для различных коэффициентов масштабирования экранов высокого разрешения.
```cpp
//Метод 1. Добавьте следующее предложение перед основной функцией. Эта функция доступна только в версии 5.6.
#if (QT_VERSION > QT_VERSION_CHECK(5,6,0))
    QGuiApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    //После включения поддержки высокого масштабирования изображение может быть воображаемым и должно быть включено следующее свойство
    QCoreApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);
#endif

//Метод 2: Создайте новый файл qt.conf в том же каталоге, что и исполняемый файл, и заполните его следующим содержимым
[Platforms]
WindowsArguments = dpiawareness=0
//Следующая строка используется для решения проблемы отображения неровного текста в Qt с высоким DPI.
WindowsArguments = fontengine=freetype

//Метод 3: установите переменные среды внутри Qt в верхней части основной функции
qputenv("QT_AUTO_SCREEN_SCALE_FACTOR", "1.5");

//Метод 4: В новой версии Qt, такой как Qt5.14, исправлена ​​обработка экранов с высоким разрешением и поддерживается масштабирование, которое не является целым числом.
qputenv("QT_ENABLE_HIGHDPI_SCALING", "1");
QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::PassThrough);

//Отключить масштабирование
//Тест показал, что свойство AA_Use96Dpi полностью нормально в Qt5.9 и выше.В следующих версиях, таких как 5.7, некоторые элементы управления ненормально увеличены на 175%, например QTextEdit, для которого требуется виджет на внешнем уровне.
#if (QT_VERSION >= QT_VERSION_CHECK(5,0,0))
    QApplication::setAttribute(Qt::AA_Use96Dpi);
#endif
#if (QT_VERSION >= QT_VERSION_CHECK(5,14,0))
    QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);
#endif
```
139. Вкладка QTabWidget имеет механизм для автоматической генерации кнопок для переключения вкладок. Иногда вы не хотите видеть эту раздражающую кнопку переключения. Вы можете установить для usesScrollButtons значение false. Фактически, свойство usesScrollButtons QTabWidget, наконец, применяется к объекту QTabBar из QTabWidget, поэтому просто установите глобальное свойство. Это свойство QTabBar можно закрыть. Почему вы хотите установить его глобально, потому что, если это свойство установлено только для QTabWidget, а автоматически сформированные вкладки слияния QDockWidget в форме QMainWindow являются только объектами QTabBar, кнопки переключения все равно остаются.
```cpp
//Для tabWidget не установлена ​​кнопка переключения
ui->tabWidget->setUsesScrollButtons(false);
//Для tabBar не установлена ​​кнопка переключения
ui->tabWidget->tabBar()->setUsesScrollButtons(false);
//Для вкладок всей системы не установлена ​​кнопка переключения
QTabBar{qproperty-usesScrollButtons:false;}
//Вкладка настроек автоматически растягивается.Эта вещь была автоматически рассчитана до того, как установить исходную встроенную вакаку.
QTabBar{qproperty-expanding:false;}
//Видна кнопка закрытия вкладки настроек
QTabBar{qproperty-tabsClosable:true;}
//Есть и другие атрибуты, см. Заголовочный файл QTabBar, есть сюрпризы
//Свойства, содержащиеся в Q_PROPERTY всех классов визуализации Универсального Дафа, могут быть установлены следующим образом
```

140. QMainWindow Размер разделительной линии по умолчанию относительно велик, и иногда я хочу сделать его меньше или нет. Сначала я подумал, что это QSplitter. После печати всех подэлементов я не нашел тени. Наконец, я обнаружил, что в таблице стилей есть соответствующие настройки.
```cpp
//Я очень мечтала вот так поставить
QMainWindow::separator{width:1px;height:1px;margin:1px;padding:1px;background:#FF0000;}
```
141. QImage поддерживает значки xpm. Вы можете найти большое количество определений значков xpm в коде в стиле QStyle, встроенном в Qt. Значки генерируются в форме кода, и это здорово.
```cpp
static const char * const imgData[] = {
    "15 11 6 1",
    "   c None",
    "+  c #979797",
    "@  c #C9C9C9",
    "$  c #C1C1C1",
    "b  c None",
    "d  c None",
    " $++++++++$    ",
    "$+bbbbbbbb+$   ",
    "+b $$      +$  ",
    "+b $@       +$ ",
    "+b           +$",
    "+b           d+",
    "+b          d+$",
    "+b $$      d+$ ",
    "+b $@     d+$  ",
    "$+dddddddd+$   ",
    " $++++++++$    "};

//Это может напрямую отображать стрелку
QImage img(imgData);
QLabel lab;
lab.setPixmap(QPixmap::fromImage(img));
lab.show();
```

142. Когда закрепленное окно QDockWidget и QOpenGLWidget используются одновременно, переключитесь из встроенного состояния в плавающее или из плавающего во встроенное состояние, контекст QOpenGLWidget будет нарушен и вызовет сбой белого экрана. поделитесь OpenGL в соответствии с настройками в начале основной функции.
```cpp
int main(int argc, char *argv[])
{
    //Необходимо установить общий контекст, иначе форма QOpenGLWidget завершится ошибкой после того, как закрепленная форма изменится с нормальной на плавающую.
#if (QT_VERSION > QT_VERSION_CHECK(5,4,0))
    QCoreApplication::setAttribute(Qt::AA_ShareOpenGLContexts);
#endif
    QApplication a(argc, argv);
    ...
}
```
143. Что касается проблемы искаженных китайских символов в Qt, я также немного резюмировал.Это должно помочь решить проблему искаженных символов в более чем 99% версий Qt.
- Первый шаг: файл кода выбирает использование кодировки utf8 с bom.
- Шаг 2: Добавьте строку в верхней части файла кода с китайскими символами (обычно это файл cpp). #Pragma execution_character_set ("utf-8") можно поместить в head.h, а затем импортировать файл заголовка, где это необходимо, Не то чтобы эта строка кода написана повсюду; эта строка кода должна сообщить компилятору msvc, что текущий файл кода скомпилирован с использованием utf8.
- Шаг 3: Добавьте код, чтобы установить кодировку в основной функции, совместимую с Qt4. Если сцены Qt4 нет, вы можете ее использовать. Начиная с Qt5, по умолчанию используется кодировка utf8.
```cpp
void QUIHelper::setCode()
{
#if (QT_VERSION <= QT_VERSION_CHECK(5,0,0))
#if _MSC_VER
    QTextCodec *codec = QTextCodec::codecForName("gbk");
#else
    QTextCodec *codec = QTextCodec::codecForName("utf-8");
#endif
    QTextCodec::setCodecForLocale(codec);
    QTextCodec::setCodecForCStrings(codec);
    QTextCodec::setCodecForTr(codec);
#else
    QTextCodec *codec = QTextCodec::codecForName("utf-8");
    QTextCodec::setCodecForLocale(codec);
#endif
}
```

144. Что касается несовместимости многих версий Qt (по крайней мере, нескольких сотен), после мозгового штурма с Лин Бином из Qt China и другими великими специалистами (группа по неофициальному обмену технологиями Qt) были наконец сделаны следующие выводы.
- Qt приложил все усилия для обеспечения бинарной совместимости: скрывая различные детали кода, метод Q-указатель + D-указатель, насколько это возможно, чтобы сохранить единство интерфейса;
- Независимо от того, совместима она или нет, главным фактором является фактор компилятора.В конце концов, любая версия Qt должна быть скомпилирована компилятором в соответствующий двоичный файл, и последнее слово остается за ним. Если две версии Qt используют одну и ту же версию компилятора, высока вероятность того, что исполняемые файлы совместимы.Например, исполняемые файлы, скомпилированные из 32-разрядной версии Qt5.10 + msvc2015 и 32-разрядной версии Qt5.11 + msvc2015, используют Qt5 .11 Библиотека возможна;
- То же самое верно и для Qt-версии компилятора mingw, потому что компилятор mingw, интегрированный в официальный установочный пакет Qt, был обновлен (за исключением очень немногих ближайших версий, которые не обновляли версию компилятора mingw), например mingw53 для 5.7, mingw73 для 5.12 и Mingw81 5.15, потому что библиотека Qt также компилируется этим компилятором, поэтому кажется, что все они несовместимы;
- Если вы хотите быть полностью совместимым, следует отметить еще один важный элемент, а именно: изменился ли интерфейс файла заголовка класса, используемого соответствующим кодом. По разным причинам исходный интерфейс будет меняться редко. Как правило, он будут вновь добавлены или изменены только после основных версий., таких как Qt4-Qt5-Qt6, которые определенно несовместимы, а интерфейсы и модули были изменены;
- Смелое предположение: если вы используете компилятор, такой как mingw73 или msvc2015, для перекомпиляции и генерации соответствующей библиотеки времени выполнения Qt из Qt5.6 в Qt5.15, а затем разрабатываете программу на этой основе, окончательно сгенерированный исполняемый файл будет использовать Qt5.15. возможны все библиотеки, поэтому он легко совместим с несколькими версиями;
- Смелое предложение: унифицируйте компиляторы в нескольких близлежащих версиях, таких как mingw53 или msvc2015 между 5.6-5.12 и msvc2017 для 5.12-5.15. Если вы хотите использовать другие компиляторы, вы можете самостоятельно скомпилировать другие версии из исходного кода, так что хотя бы По умолчанию совместимо большое количество ближайших версий (примерно 2-3 года цикла версий).
- Я тестировал часть виджета, qml не тестировался, и неясно, такой же ли механизм;

145. Под руководством классного брата по коду (группа обмена разработчиками Qt) до сегодняшнего дня я не знал, что таблица стилей настроек Qt поддерживает прямой ввод пути к файлу таблицы стилей. Протестируйте любую версию от 4.7 до 5.15. Вы можете видеть внутренний, проверив исходный код соответствующей функции.Он проверит, начинается ли он с 'файл: ///', если да, он автоматически прочитает файл таблицы стилей для настройки, нет необходимости читать его вручную.
```cpp
//Следующие методы использовались
QFile file(":/qss/psblack.css");
if (file.open(QFile::ReadOnly)) {
    QString qss = QLatin1String(file.readAll());
    qApp->setStyleSheet(qss);
    file.close();
}

//Фактически, одна строка кода будет делать
qApp->setStyleSheet("file:///:/qss/psblack.css");
//В частности, поддерживается только qApp-> setStyleSheet, а другие, такие как widget-> setStyleSheet, не поддерживаются.
```
146. Многие элементы управления, поставляемые с Qt, на самом деле состоят из набора базовых элементов управления (QLabel, QPushButton и т. Д.). Например, панель календаря QCalendarWidget состоит из QToolButton + QSpinBox + QTableView и т. Д. Магическое использование findChildren может дать коллекция дочерних элементов управления, соответствующих родительскому классу., Вы можете напрямую установить стиль вложенных элементов управления в инкапсулированном элементе управления и установить другие параметры, такие как установка китайского текста (по умолчанию может быть английский) и так далее.
```cpp
//Распечатать коллекцию имен подклассов
void printObjectChild(const QObject *obj, int spaceCount)
{
    qDebug() << QString("%1%2 : %3")
             .arg("", spaceCount)
             .arg(obj->metaObject()->className())
             .arg(obj->objectName());

    QObjectList childs = obj->children();
    foreach (QObject *child, childs) {
        printObjectChild(child, spaceCount + 2);
    }
}

//Получите диалоговое окно, чтобы установить и украсить
QFileDialog *fileDialog = new QFileDialog(this);
fileDialog->setOption(QFileDialog::DontUseNativeDialog, true);
QLabel *lookinLabel = fileDialog->findChild<QLabel*>("lookInLabel");
lookinLabel->setText(QString::fromLocal8Bit("文件目录："));
lookinLabel->setStyleSheet("color:red;");

//Установите значение по умолчанию для поля даты, чтобы оно было пустым
QLineEdit *edit = ui->dateEdit->findChild<QLineEdit *>("qt_spinbox_lineedit");
if (!edit->text().isEmpty()) {
    edit->clear();
}
```

147. Qt имеет встроенные различные диалоги, такие как файл dialog-QFileDialog и цветной диалог-QColorDialog. По умолчанию, стиль стиля диалога системы будет принят, так что он может быть согласован с системой. Если это не нужно, вы можете отменить эту возможность.Используйте собственное диалоговое окно Qt, чтобы украсить и выполнить другую обработку.
```cpp
QFileDialog *fileDialog = new QFileDialog(this);
//Если вы не установите этот атрибут, вы вообще не найдете никаких дочерних элементов, потому что диалоговое окно системы по умолчанию
fileDialog->setOption(QFileDialog::DontUseNativeDialog, true);
qDebug() << fileDialog->findChildren<QLabel *>();
//Распечатать QLabel(0x17e2ff68, name="lookInLabel"), QLabel(0x17e35f88, name="fileNameLabel"), QLabel(0x17e35e68, name="fileTypeLabel")
```

148. Интегрированная среда разработки Qt Creator также имеет встроенную поддержку для быстрого добавления комментариев.Например, наиболее часто используется добавление большого раздела общих комментариев шаблона в начале файла заголовка, чтобы отметить создателя файла, время и другая информация.
- Меню -> Инструменты -> Параметры -> Текстовый редактор -> Фрагменты страниц правой вкладки (сниппеты);
- Выберите C ++ в группе, вы увидите, что есть много встроенных определений, таких как foreach, которые можно нарисовать в соответствии с тыквой;
- Добавьте сегмент, например, название весело, а тип триггера - это краткое описание сегмента;
- Когда мы вводим веселье в файл кода, автоматически всплывает умное напоминание, выбираем наш фрагмент кода и нажимаем Enter для автоматического заполнения кода;
- Нажимайте вкладку для переключения между переменными, нажмите Enter после ввода для завершения редактирования;
```cpp
/**
  * @brief $name$
  * @param $param$
  * @author feiyangqingyun
  * @date $date$
  */
$ret$ $name$($param$)
{
    $$
}
```

149. Говорят, что механизм работы сигнального слота был значительно улучшен в эпоху Qt5.
- До Qt5 команду connect можно было записать только так: connect (sender, SIGNAL (signalFunc ()), Receiver, SLOT (receiveFunc ())), что означает, что когда вы подключаетесь, вы должны обернуть сигнал макросом SIGNAL, чтобы поставить слот Функция обернута макросом SLOT, так что он может быть распознан механизмом Qt Moc;
- При компиляции, даже если сигнал или слот не существует или параметр неверен, он не будет сообщать об ошибке, но он будет недопустимым при выполнении, и будет напечатано приглашение. Для статического языка, такого как C ++, это недружелюбный и не способствующий отладке;
- Однако после Qt5 более рекомендуется "писать адрес". Используя этот метод, если сигнал или слот не существует при компиляции, компиляция не может быть передана, что эквивалентно проверке во время компиляции, и это не так. легко ошибаться;
- Если нет исторических проблем и требуется совместимость с Qt4, рекомендуется использовать новый метод записи, который имеет более строгую проверку типов, поддерживает различные методы записи и является очень гибким;
- Настоятельно рекомендуется использовать некоторую простую логику обработки для прямой обработки лямбда-выражения;
```cpp
class MainWindow : public QMainWindow
{
    Q_OBJECT

public: MainWindow(QWidget *parent = 0);
    ~MainWindow();

private:
    Ui::MainWindow *ui;

private:
    void test_fun();

private slots:
    void test_slot();
};

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    //Ранняя версия, все версии общего Qt, поддерживали только функции, определенные с помощью ключевого слова slots
    //connect(ui->pushButton, SIGNAL(clicked()), this, SLOT(test_fun()));
    connect(ui->pushButton, SIGNAL(clicked()), this, SLOT(test_slot()));

    //Новый метод записи, поддержка Qt5 и всех более поздних версий, поддержка всех функций, нет необходимости определять ключевое слово slots
    connect(ui->pushButton, &QPushButton::clicked, this, &MainWindow::test_fun);
    connect(ui->pushButton, &QPushButton::clicked, this, &MainWindow::test_slot);

    //Альтернативное написание, поддержка лямбда-выражений, выполнение кода напрямую
    connect(ui->pushButton, &QPushButton::clicked, [this] {test_fun();});
    connect(ui->pushButton, &QPushButton::clicked, [this] {
        qDebug() << "hello lambda";
    });

    //lambda С параметрами
    connect(ui->pushButton, &QPushButton::clicked, [&] (bool isCheck) {
        qDebug() << "hello lambda" << isCheck;
    });

    //файл головы signals:void sig_test(int i);
    connect(this, &MainWindow::sig_test, [] (int i) {
        qDebug() << "hello lambda" << i;
    });
    emit sig_test(5);
}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::test_fun()
{
    qDebug() << "test_fun";
}

void MainWindow::test_slot()
{
    qDebug() << "test_slot";
}
```

150. Таблицы стилей Qt имеют множество операционных механизмов, в основном с учетом различных сценариев спроса, классы, унаследованные от классов QWidget и qApp, поддерживают метод setStyleSheet, и вы также можете равномерно размещать таблицы стилей в файлах или добавлять файлы стилей в файлы ресурсов.
- Gritty: содержимое Qss пишется везде и везде, где это необходимо, различные элементы управления вызывают метод setStyleSheet для передачи содержимого таблицы стилей или напрямую соответствуют правой кнопке мыши элемента управления и выбирают изменение таблицы стилей для заполнения содержимого .；
- Fighter: содержимое qss помещается в файл, содержимое файла читается, таблица стилей устанавливается, а файл qss загружается при выпуске программы;
- Doushi: файл qss помещается в файл qrc как файл ресурсов, и он напрямую компилируется в исполняемый файл для предотвращения взлома;
- Доу Линг: настроить некоторые флаги в файле css для использования в качестве переменных и заменить соответствующие переменные значениями цвета после чтения, аналогично динамическому созданию скинов;
- Доуванг: Файл легко подделать, и он недостаточно гибок для интеграции в исполняемый файл. После обновления таблицы стилей файл необходимо перекомпилировать. Как я могу обновить файл таблицы стилей без перекомпиляции исполняемого файла Файл? Изменен: используйте команду rcc, чтобы скомпилировать файл ресурсов в двоичный файл, и вам нужно только заменить двоичный файл;
- Douhuang: наследуйте класс qstyle, чтобы реализовать все интерфейсы стилей самостоятельно, унифицируйте общий стиль, известное правило по умолчанию для системы UOS выглядит следующим образом: не разрешается использовать таблицы стилей, все рисование рисует;

151. Когда скомпилированный файл ресурсов в Qt слишком велик, эффективность очень низкая или файлы в файле ресурсов, такие как изображения, таблицы стилей и т. Д., Должны быть изменены, а исполняемый файл необходимо перекомпилировать. Конечно, Qt дал нам хорошую стратегию., В настоящее время файл ресурсов может быть преобразован в двоичный файл rcc, так что файл ресурсов будет разделен и может быть динамически загружен при необходимости.
```cpp
//Метод использования двоичных файлов ресурсов в Qt следующий
//Скомпилируйте qrc в двоичный файл rcc, выполните следующие команды на консоли
rcc -binary main.qrc -o main.rcc
//Зарегистрируйте ресурсы в приложении, обычно после запуска основной функции
QResource::registerResource(qApp->applicationDirPath() + "/main.rcc");
```

152.Что касается установки шрифтов, вероятно, возникло недоразумение. Изначально я планировал установить размер шрифта для всей формы, включая дочерние элементы управления. Оказалось, что только основная форма сама применила шрифт, а дочерние элементы управления - нет.
```cpp
//Предполагая, что в форме есть дочерние элементы управления, шрифт по умолчанию - 12 пикселей, тип родительского класса - QWidget, а имя родительского класса - Widget.

//Следующие методы устанавливают только шрифт основной формы, а дочерние элементы управления не применяются. Вам необходимо вызывать setFont один за другим.
QFont font;
font.setPixelSize(20);
this->setFont(font);
this->setStyleSheet("{font:26px;}");
this->setStyleSheet("QWidget{font:26px;}");
this->setStyleSheet("Widget{font:26px;}");

//Следующее - установить шрифт всего элемента управления + субэлементы управления через таблицу стилей.
this->setStyleSheet("font:26px;");
this->setStyleSheet("*{font:26px;}");
this->setStyleSheet("QWidget>*{font:26px;}");
this->setStyleSheet("Widget>*{font:26px;}");

//Установите глобальный шрифт ниже
qApp->setFont(font);
```
153.QImage, упакованный в Qt, чрезвычайно мощный. Он обеспечивает преобразование различных форматов изображений, а также может заменять значение цвета каждого пикселя. Иногда нам нужно изменить монохромное изображение на другой цвет. Следует отметить, что если цвет с прозрачностью значение необходимо отформатировать, например format_ARGB32 или Format_RGBA8888.
```cpp   
//pixel      Функция получает цвет пикселя. Функция getPixel устанавливает цвет пикселя. Эта функция доступна в любой версии Qt.
//pixelColor Функция получает цвет пикселя. Функция setPixelColor устанавливает цвет пикселя. Эта функция доступна только после Qt5.6.
//pixel Функция выводит то, что формат QRgb необходимо преобразовать с помощью qRed qGreen qBlue qAlpha
QImage image("1.png");
image = image.convertToFormat(QImage::Format_ARGB32);
int width = image.width();
int height = image.height();
//Обойти каждый пиксель изображения
for (int x = 0; x < width; ++x) {
    for (int y = 0; y < height; ++y) {
        QString name = image.pixelColor(x, y).name();
        //Замените все цвета, кроме белого, на красный
        if (name != "#ffffff") {
            image.setPixelColor(x, y, Qt::red);
        }
    }
}

//сохранить документ
image.save("2.png");
```
154.В приложениях, связанных с базами данных, если это только автономная версия и нет особой необходимости (например, назначение руководства или необходимость удаленного хранения данных), настоятельно рекомендуется использовать базу данных sqlite, которая у меня есть. прошли бесчисленное количество сравнительных тестов и N коммерческих проектов приложений заключение.
- Qt рожден со встроенной базой данных sqlite, вам нужно только принести плагин при публикации (вы можете видеть, что файл динамической библиотеки плагина больше, чем другие типы, потому что исходный код базы данных напрямую скомпилирован, а остальные - только скомпилированный исходный код подключаемого модуля для промежуточного коммуникационного взаимодействия), другие базы данных должны либо приносить динамические библиотеки, либо создавать источники данных;
- По скорости он не имеет себе равных. Такая же структура базы данных (структура таблицы, индекс и т. Д.), Скорость запросов и скорость пакетного обновления, транзакции базы данных и т. Д. Как минимум в 3 раза быстрее, чем у других типов, и с количество данных Увеличение контрастности становится более очевидным;
- Объем данных в десятки миллионов вполне нормален, а скорость и производительность в порядке. Не искажайте объем данных, превышающий один миллион, не поддерживается некоторыми Caiji в Интернете. Я лично тестирую объем данных в 100 миллионов • Рекомендуется, чтобы объем данных был ниже 10 млн. Обратите внимание на дизайн таблиц и индексов базы данных;
- Другие базы данных также должны обращать внимание на разницу в версиях, формат источника данных ODBC также подвержен ошибкам и сбоям выполнения;
- База данных sqlite также имеет несколько основных недостатков: она не поддерживает шифрование, доступ к сети, расширенные функции некоторых баз данных и большие объемы данных (более 100 миллионов), но этого все же достаточно для большинства проектов Qt;
- Дружественность к поддержке базы данных составляет примерно sqlite> postgresql> mysql> odbc;
- Выше приведены выводы, сделанные на основе личных тестов в среде Qt. Результаты могут быть неверными, просто для справки. Не обращайте внимания на другие среды программирования, такие как C # и JAVA. Возможно, разница может быть вызвана эффективностью взаимодействия;

155. После Qt5.10 для управления случайными числами предоставляется новый класс QRandomGenerator QRandomGenerator64, который более удобен в использовании, особенно для получения случайных чисел в определенном интервале.
```cpp
//Метод раннего лечения: сначала инициализируйте начальное число случайных чисел, а затем возьмите случайное число
qsrand(QTime::currentTime().msec());
//Возьмите случайное число от 0 до 10.
qrand() % 10;
//Возьмите число с плавающей запятой от 0 до 1
qrand() / double(RAND_MAX);

//Новая версия решения поддерживает все версии после 5.10, включая qt6.
QRandomGenerator::global()->bounded(10);      //生成一个0和10之间的整数
QRandomGenerator::global()->bounded(10.123);  //生成一个0和10.123之间的浮点数
QRandomGenerator::global()->bounded(10, 15);  //生成一个10和15之间的整数

//Метод, совместимый с qt4-qt6 и всеми более поздними версиями, заключается в использовании стандартной функции случайных чисел C ++.
srand(QTime::currentTime().msec());
rand() % 10;
rand() / double(RAND_MAX);

//Общая формула a - начальное значение, n - диапазон целых чисел
int value = a + rand() % n;
//(min, max)Случайный номер
int value = min + 1 + (rand() % (max - min - 1));
//(min, max]Случайный номер
int value = min + 1 + (rand() % (max - min + 0));
//[min, max)Случайный номер
int value = min + 0 + (rand() % (max - min + 0));
//[min, max]Случайный номер
int value = min + 0 + (rand() % (max - min + 1));

//Если случайное число берется в потоке, время начала потока почти такое же. Очень вероятно, что полученное случайное число будет таким же. Даже если случайное число установлено на текущее время, оно бесполезно. комп слишком шустрый, время может быть то же самое., та же миллисекунда.
//Хитрость заключается в том, чтобы установить идентификатор текущего потока в качестве начального числа перед функцией запуска. Время ненадежно, а идентификатор потока уникален.
//Помните, что void * необходимо преобразовать в числовое значение с long long. Можно использовать int в 32-битном, но должно быть long в 64-битном. Убедитесь, что вы используете quint64 напрямую, если он самый большой
srand((long long)currentThreadId());
qrand((long long)currentThreadId());
```
156. Интерфейс пользовательского интерфейса Qt имеет ошибку после изменения размера, стиль наведения не отменяется, и вам необходимо активно имитировать движение мыши.
```cpp
void frmMain::on_btnMenu_Max_clicked()
{
    ......

    //После разворачивания появляется ОШИБКА, стиль наведения не отменяется, нужно активно имитировать движение мыши 
    QEvent event(QEvent::Leave);
    QApplication::sendEvent(ui->btnMenu_Max, &event);    
}
```
157. В проекте включена поддержка синтаксиса C ++ 11.
```cpp
greaterThan(QT_MAJOR_VERSION, 4): CONFIG += c++11
lessThan(QT_MAJOR_VERSION, 5): QMAKE_CXXFLAGS += -std=c++11
```
158. Текстовые элементы управления Qt, такие как QTextEdit, по умолчанию загружают большие тексты, такие как текст размером 10 МБ, и их легко заморозить или даже привести к сбою, потому что свойство включено по умолчанию, и гораздо лучше заблокировать его.
```cpp
ui->textEdit->setUndoRedoEnabled(false);
```
159. Другой регулярный опыт, я много раз боролся в этих местах.
- Для функций с возвращаемыми значениями вы должны активно возвращать возвращаемое значение.Некоторые компиляторы могут компилировать и передавать в обычном режиме без возвращаемого значения, но во время работы будут возникать проблемы, и желаемый результат не будет получен из-за отсутствия соответствующего возврата. Value.
- Хорошая привычка заключается в том, что вы должны разработать определенную локальную переменную, которая будет активно давать начальное значение. В противном случае начальное значение, данное компилятором, вероятно, не то, что вы хотите. Например, для переменной int по умолчанию установлено значение 0, а иногда оно становится большое случайно.Численное значение, начальное значение переменной bool отличается от компилятора, некоторые из них истинны, а некоторые - ложны. Надежнее активно давать начальное значение.
- Некоторых параметров функции много, и они могут быть изменены и добавлены позже, что приводит к модификации связанного слота сигнала после изменения источника. Тип и положение параметра должны быть полностью согласованными, и соответствующая обработка функции слота также должна быть модифицированный и т. д. Объем изменения очень велик и крайне недружелюбен. Поэтому для функций с нефиксированными параметрами рекомендуется использовать структуры. Очень легко добавить другие параметры, и нет необходимости изменять определение связи сигнального слота и определение функции сигнального слота, например, таблицы информации о студентах. Таблица информации о товарах передается как параметр, и лучшим решением является структура.

160. QTabWidget tab control, сгенерированная ширина вкладки панели вкладок автоматически устанавливается в соответствии с текстом. Чем длиннее текст, тем больше ширина вкладки. Во многих случаях нам нужна такая же ширина или равное заполнение.
```cpp
//Метод 1: заполнение строкового пробела
ui->tabWidget->addTab(httpClient1, "测    试");
ui->tabWidget->addTab(httpClient1, "人员管理");
ui->tabWidget->addTab(httpClient1, "系统设置");

//Метод 2: Распознать событие изменения размера и автоматически установить минимальную ширину
void MainWindow::resizeEvent(QResizeEvent *e)
{
    int count = ui->tabWidget->tabBar()->count();
    int width = this->width() - 30;
    QString qss = QString("QTabBar::tab{min-width:%1px;}").arg(width / count);
    this->setStyleSheet(qss);
}

//Метод 3: Установите глобальный стиль, установите разную ширину для количества разных вкладок
QStringList list;
list << QString("QTabWidget[tabCount=\"2\"]>QTabBar::tab{min-width:%1px;}").arg(100);
list << QString("QTabWidget[tabCount=\"3\"]>QTabBar::tab{min-width:%1px;}").arg(70);
qApp->setStyleSheet(list.join(""));
//Установите слабый атрибут tabCount для автоматического поиска соответствующей настройки ширины
ui->tabWidget->setProperty("tabCount", 2);
ui->tabWidget->setProperty("tabCount", 3);

//Метод 4: Настоятельно рекомендуется - «Используйте встроенный метод setExpanding setDocumentMode. Необходимо установить оба свойства.
//Предполагается, что Qt4 tabBar (), поэтому рекомендуется установить его через таблицу стилей.
ui->tabWidget->tabBar()->setDocumentMode(true);
ui->tabWidget->tabBar()->setExpanding(true);
//Таблица стилей создается за один шаг, нет необходимости настраивать каждую отдельно
QString("QTabBar{qproperty-usesScrollButtons:false;qproperty-documentMode:true;qproperty-expanding:true;}");
//在5.9 После включения этого параметра раньше кажется, что количество вкладок рассчитывается в соответствии с действительным числом +1, что означает, что место вкладки всегда будет оставаться пустым.
//5.9 Похоже, что эта ОШИБКА будет исправлена ​​в будущем, и ширина вкладки выставлена ​​в равных частях в соответствии с идеальным растяжением и заливкой.
```
161. Некоторые люди часто говорят, что Qt - это чушь, говоря, что использование Qt для рисования тысяч точек данных за 1 миллисекунду - это дерьмо. На самом деле максимальная частота обновления монитора обычно составляет всего 60 кадров, имеет ли смысл рисовать один раз в 1 миллисекунду? Мало того, что дисплей не обновляется, но человеческий глаз не может его видеть (кому-то, возможно, придется поднять планку и сказать, что этого требует начальник, и дисплей отобразится. Что касается людей, которые его не видят Я хочу сказать, что дисплей не для "Могут ли люди его видеть?" вам нужно сделать в программе - это попытаться снизить частоту обновления отрисовки программы до частоты отображения (на самом деле достаточно 30 кадров в секунду), за раз отрисовывается немного больше данных (для большого количества данных, вы также можете рассмотреть возможность повторной выборки, такой как метод усреднения и т. д.) Что вы имеете в виду, вы можете заменить точку данных во всей области одной точкой) вместо рисования несколько раз. Хотя оба метода могут рисовать полученные данные , разница в эффективности незначительна, и то же самое верно и для сигнала. Не рекомендуется посылать сигналы слишком часто. Qt имеет ограничение на количество сигналов, обрабатываемых за 1 секунду. Слишком частые и высокие сигналы в параллельном режиме может быть потеряна или объединена, например, таблица информации о студенте, полученная по сетевому запросу.Вся информация о студенте в данных ответа анализируется и отправляется сразу, вместо того, чтобы анализировать один за другим и отправлять одну за другой.
162. Qt предоставляет N типов свойств окна, таких как свойство без полей FramelessWindowHint, свойство Tool не отображается на панели задач и т. Д. Иногда нам нужно динамически устанавливать свойства окна, например, добавление свойства или удаление свойства, которое требует должно быть выполнено до Qt5.9. Для выполнения вычислений свойств исходной формы позже можно будет использовать новые методы.
```cpp
//Добавить свойство без полей
setWindowFlags(windowFlags() | Qt::FramelessWindowHint);
//Удалить атрибут без полей
setWindowFlags(windowFlags() & ~Qt::FramelessWindowHint); 
//Ниже приводится новый метод после версии 5.9.
//Добавить свойство без полей в список свойств формы
setWindowFlag(Qt::FramelessWindowHint, true);
//Удалите атрибут без полей из списка атрибутов окна
setWindowFlag(Qt::FramelessWindowHint, false);
```
163. Если вы установите для окна фиксированный размер, окно станет нерастяжимым.Если вам нужно восстановить его, чтобы растянуть, вы должны сбросить минимальный размер и максимальный размер.
```cpp
setMinimumSize(0, 0);
setMaximumSize(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX);
```
164. Qt имеет встроенное множество параметров глобального объекта, которые можно получить напрямую, так что это удобно, когда он не нужен при его использовании. Например, вы можете напрямую использовать qApp-> mouseButtons (), чтобы определить текущую левую или правую кнопку мыши. , а глобальные координаты мыши могут использовать QCursor :: pos ().
```cpp
//Меню появляется при нажатии правой кнопки мыши. Если меню представляет собой QMenu, а не QAction, оно может всплывать только следующим образом.
if (qApp->mouseButtons() == Qt::RightButton) {
    videoMenu->exec(QCursor::pos());
}

//Глобальный буфер обмена
qApp->clipboard();
//Коллекция объектов управления верхнего уровня
qApp->topLevelWidgets()
//Текущий элемент управления фокусом
qApp->focusWidget()
//Текущее название платформы
qApp->platformName()
//Вызов системного зуммера
qApp->beep()
//Распечатать информацию о текущей версии Qt
qApp->aboutQt()
//Установите глобальный стиль мыши
qApp->setOverrideCursor()
//Не используйте стандартные цветные шрифты системы и т. Д.
QGuiApplication::setDesktopSettingsAware(bool on);
QApplication app(argc, argv);

//Для получения дополнительных сведений о свойствах глобальных объектов обратитесь к заголовочному файлу qguiapplication.h, вы найдете Newland.
```

165. Qt также провел очень подробную обработку, чтобы различать разные компиляторы.
```cpp
#pro О файле можно судить так
msvc{}

//О коде можно судить так
#ifdef Q_CC_MINGW
//mingw 
#elif Q_CC_MSVC
//msvc 
#endif

//Определите компилятор и версию компилятора
#if defined Q_CC_MSVC && _MSC_VER < 1300
#if defined(Q_CC_GNU) && (__GNUC__ < 4)

//Оцените платформу ARM в коде
#ifdef QT_ARCH_ARM
//Оценка множественных условий
#if defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE)
```
166. Иногда необходимо временно запретить определенному элементу управления излучать сигнал (например, когда поле со списком добавляет данные в раскрывающийся список, он запускает текущий элемент для изменения сигнала), существует много видов обработки, это рекомендуется использовать метод blockSignals.
```cpp
//Способ 1. Сначала отключите сигнал, а затем подключите сигнал после обработки. Недостатки очевидны и бестолковы. Если сигналов много, нужно сделать это один раз для каждой модели.
disconnect(ui->cbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int)));
for (int i = 0; i <= 100; i++) {
    ui->cbox->addItem(QString::number(i));
}
connect(ui->cbox, SIGNAL(currentIndexChanged(int)), this, SLOT(on_cbox_currentIndexChanged(int)));

//Метод 2: сначала вызовите blockSignals (true), чтобы заблокировать сигнал, а затем вызовите blockSignals (false), чтобы восстановить все сигналы после обработки числа.
//Если вам нужно указать сигнал для отключения, вы можете использовать только функцию Disconnect для его обработки.
ui->cbox->blockSignals(true);
for (int i = 0; i <= 100; i++) {
    ui->cbox->addItem(QString::number(i));
}
ui->cbox->blockSignals(false);
```
167. Если файлов с кодом проекта много, все, что включено в файл профессионального проекта, будет очень беспорядочным, и даже полосу прокрутки придется растягивать в течение длительного времени. Есть два способа справиться с этим лучше, рекомендуемый метод 2 .
```cpp
//Метод 1: Импортируйте все профессиональные файлы напрямую, вместо того, чтобы добавлять каждый по одному, что избавляет от беспокойства и усилий.
HEADERS += *.h
SOURCES += *.cpp

//Метод 2: Хранить в папках модулей. Различные модули используют pri для включения файлов кода. Например, интерфейс можно поместить в папку ui, и ниже создается ui.pri, а затем файл проекта pro должен только импортировать его. pri файл.
include($$PWD/ui/ui.pri)
//Вы также можете добавить предложение пути включения, чтобы вам не нужно было писать папку при использовании кода
INCLUDEPATH += $$PWD/ui
//Добавьте указанную выше строку, вы можете напрямую включить «form.h» при использовании файла заголовка, и вам нужно будет включить «ui / form.h», если вы его не добавите.
```
168. В сетевой коммуникации, будь то клиент TCP или клиент UDP, на самом деле возможно привязать IP-адрес и порт сетевой карты.Многие знают только то, что сервер может указать порт прослушивания сетевой карты. Если клиент не привязан к коммуникационному порту, он будет случайным образом и постепенно выделяться операционной системой, в которой находится клиент. Почему это подчеркивается здесь, потому что бесчисленное количество людей и даже некоторые сельскохозяйственные рабочие нового поколения с многолетним опытом Опыт показывает, что порт клиента выделен сервером. Да, потому что они видят, что разные номера портов могут быть распечатаны после того, как соединение установлено на стороне сервера. Обе стороны в сетевом взаимодействии решают, какой порт они хотят использовать. Сервер может только решить, какой порт он прослушивает, а не порт клиента. Точно так же клиент может выбрать только свой собственный порт. Случайное распределение портов обычно увеличивается по порядку. Например, порт 45110 используется первым, а порт 45111 используется для восстановления соединения. Пока порт не занят, он будет увеличиваться таким образом. Многие люди будут спросите, можно ли повторно использовать некоторые порты, иначе порты всегда будут такими частыми.Распределение не подходит, даже некоторые конкретные сценарии и требования потребуют от клиента привязки сетевой карты и порта для связи с сервером.
```cpp
//клиент tcp
QTcpSocket *socket = new QTcpSocket(this);
//Отключите все соединения и операции
socket->abort();
//Привязать сетевую карту и порт
socket->bind(QHostAddress("192.168.1.2"), 6005);
//подключиться к серверу
socket->connectToHost("192.168.1.3", 6000);

//Распечатайте локальный адрес привязки и порт, используемый для связи
qDebug() << socket->localAddress() << socket->localPort();
//Распечатайте адрес и порт другой стороны коммуникационного сервера.
qDebug() << socket->peerAddress() << socket->peerPort() << socket->peerName();

//клиент udp
QUdpSocket *socket = new QUdpSocket(this);
//Привязать сетевую карту и порт, привязать нужно если не привязал
//Для удобства судить, являются ли порты одинаковыми, вы можете напрямую связывать и переключать порты динамически
if (socket->localPort() != 6005) {
    socket->abort();
    socket->bind(QHostAddress("192.168.1.2"), 6005);
}
//Укажите адрес и порт для отправки данных
socket->writeDatagram(buffer, QHostAddress("192.168.1.3"), 6000);

//Вышесказанное заключается в том, что Qt5 может использовать связывание, а соответствующий интерфейс QTcpSocket в Qt4 защищен и не может использоваться напрямую.Вам необходимо унаследовать класс, чтобы повторно реализовать интерфейс, чтобы освободить его.
//Функция связывания QUdpSocket в Qt4 открыта.Странно, почему уникальный QTcpSocket в Qt4 не открыт.
TcpSocket *socket = new TcpSocket(this);
socket->setLocalAddress(QHostAddress("192.168.1.2"));
socket->setLocalPort(6005);
```
169. Что касается сетевой связи, tcp и udp - это два разных протокола сетевой связи низкого уровня. Порты мониторинга и связи этих двух протоколов независимы друг от друга. Один и тот же порт может использоваться разными протоколами или разными IP-адресами сетевых карт. Кто-то сказал, что его компьютер может прослушивать один и тот же порт для связи, что подорвало его прежнее понимание. В книге четко сказано, что тот же порт нельзя использовать. Позже я удаленно посмотрю на исходный IP-адрес другой сетевой карты. Конечно, все в порядке.
-TCP контролирует порт 6000 на сетевой карте 1, а также может контролировать порт 6000 на сетевой карте 2.
-TCP контролирует порт 6000 на сетевой карте 1, а udp может продолжать контролировать порт 6000 на сетевой карте 1.
-TCP контролирует порт 6000 на сетевом адаптере 1, а другие протоколы TCP на сетевом адаптере 1 могут отслеживать только порты, отличные от 6000.
-Протокол udp также соответствует вышеуказанной логике.

170. Элемент управления диаграммами с открытым исходным кодом QCustomPlot является очень классическим: он демонстрирует высокую производительность в данных кривых и обобщает некоторые моменты опыта, которые легко упустить из виду.
-Ось XY может быть перевернута, чтобы сформировать горизонтальный эффект, будь то график кривой или столбец, групповой график, составной график и т. Д., Эта функция поддерживается.
-Необходимая легенда подсказки может быть удалена с помощью вызова legend-> removeItem.
-Две кривые можно объединить в одну область, вызвав setChannelFillGraph.
-Вы можете отключить настройку сглаживания Anti-aliasing для ускорения рисования.
-Вы можете установить разные стили линий (setLineStyle) и стили данных (setScatterStyle).
-Стиль стрелки оси координат можно заменить на setUpperEnding.
-Вы можете использовать QCPBarsGroup для реализации столбчатой ​​групповой диаграммы.Этого класса нет в официальной демонстрации, поэтому его очень легко игнорировать.

```cpp
//Поменяйте местами ось XY и установите ее спереди
QCPAxis *yAxis = customPlot->yAxis;
QCPAxis *xAxis = customPlot->xAxis;
customPlot->xAxis = yAxis;
customPlot->yAxis = xAxis;

//Удалить легенду
customPlot->legend->removeItem(1);

//Объедините два изогнутых полотна, чтобы образовать замкнутую зону.
customPlot->graph(0)->setChannelFillGraph(customPlot->graph(1));

//Отключить сглаживание и отключить сглаживание при перетаскивании
customPlot->graph()->setAntialiased(false);
customPlot->setNoAntialiasingOnDrag(true);

//Различные способы установки данных
customPlot->graph(0)->setData();
customPlot->graph(0)->data()->set();

//Установите разные стили линий и стили данных
customPlot->graph()->setLineStyle(QCPGraph::lsLine);
customPlot->graph()->setScatterStyle(QCPScatterStyle::ssDot);
customPlot->graph()->setScatterStyle(QCPScatterStyle(shapes.at(i), 10));

//Его также можно установить как изображение или произвольную форму.
customPlot->graph()->setScatterStyle(QCPScatterStyle(QPixmap("./sun.png")));
QPainterPath customScatterPath;
for (int i = 0; i < 3; ++i) {
    customScatterPath.cubicTo(qCos(2 * M_PI * i / 3.0) * 9, qSin(2 * M_PI * i / 3.0) * 9, qCos(2 * M_PI * (i + 0.9) / 3.0) * 9, qSin(2 * M_PI * (i + 0.9) / 3.0) * 9, 0, 0);
}
customPlot->graph()->setScatterStyle(QCPScatterStyle(customScatterPath, QPen(Qt::black, 0), QColor(40, 70, 255, 50), 10));

//Измените стиль стрелки оси координат
customPlot->xAxis->setUpperEnding(QCPLineEnding::esSpikeArrow);
customPlot->yAxis->setUpperEnding(QCPLineEnding::esSpikeArrow);

//Установить фоновое изображение
customPlot->axisRect()->setBackground(QPixmap("./solarpanels.jpg"));
//Canvas также может установить фоновое изображение
customPlot->graph(0)->setBrush(QBrush(QPixmap("./balboa.jpg")));
//Можно установить общий цвет заливки или изображение
customPlot->setBackground(QBrush(gradient));
//Установить цвет нулевой линии
customPlot->xAxis->grid()->setZeroLinePen(Qt::NoPen);
//Управляйте масштабированием, перетаскиванием колесика мыши и другими интерактивными формами.
customPlot->setInteractions(QCP::iRangeDrag | QCP::iRangeZoom | QCP::iSelectPlottables);

//Гистограмма
QCPBarsGroup *group = new QCPBarsGroup(customPlot);
QList<QCPBars*> bars;
bars << fossil << nuclear << regen;
foreach (QCPBars *bar, bars) {
    //Установите ширину гистограммы
    bar->setWidth(bar->width() / bars.size());
    group->append(bar);
}
//Установите интервал между группами
group->setSpacing(2);
```
171. Проблемы с кодировкой часто встречаются при программировании Qt. Из-за кроссплатформенности и совместимости с различными системами, система Windows по умолчанию использует кодировку gbk или gb2312. Конечно, компилятор msvc может поддерживать кодировку utf8 в более поздний период, поэтому он импортируется в некоторых программах Когда обнаруживается, что имя файла китайского каталога не работает, потому что соответствующий интерфейс может использовать более раннюю функцию fopen вместо функции fopen_s, например, это также имеет место в fmod. В настоящее время требуется перекодирование.
```cpp
QString fileName = "c:/1.txt";
//Если код не установлен в основной функции приложения, по умолчанию используется системный код, который можно напрямую преобразовать в правильные данные с помощью toLocal8Bit.
const char *name = fileName.toLocal8Bit().constData();

//Если вы установили следующие два предложения, вам необходимо активно перекодировать
QTextCodec *codec = QTextCodec::codecForName("utf-8");
QTextCodec::setCodecForLocale(codec);

QTextCodec *code = QTextCodec::codecForName("gbk");
const char *name = code->fromUnicode(fileName).constData();

//Рекомендуемый метод 2 - на всякий случай, чтобы убедиться, что он абсолютно правильный, даже если была установлена ​​кодировка основной программы.
//Помните, что как только QTextCodec :: setCodecForLocale установлен, toLocal8Bit будет затронут

//Иногда может возникнуть следующая ситуация
#ifdef Q_OS_WIN
#if defined(_MSC_VER) && (_MSC_VER >= 1400)
    QTextCodec *code = QTextCodec::codecForName("utf-8");
#else
    QTextCodec *code = QTextCodec::codecForName("gbk");
#endif
    const char *name = code->fromUnicode(fileName).constData();
#else
    const char *name = fileName.toUtf8().constData();
#endif
```
172. В процессе консультации и изучения исходного кода Qt были обнаружены некоторые тенденции и изменения.
-Для типа данных попробуйте использовать внутренний тип данных Qt, даже если он переопределен, например, quint8 на самом деле беззнаковый char, а qreal - двойной. При просмотре исходного кода раньше некоторые из них могут быть двойными, но теперь медленно меняется на qreal.
-Структура цикла использует for (;;) вместо while (1), потому что после преобразования в инструкции сборки for (;;) имеет только одну инструкцию, а while (1) имеет 4 инструкции.Инструкции не занимают регистры и не надо прыгать Теория Скорость должна быть выше.
-Фактически, ключевое слово forever переопределено в Qt, чтобы означать (;;), мой поступок, я действительно вдумчивый.
-Автоматический C ++ 11 и последующие стандарты поддерживают универсальный тип данных auto. Было обнаружено, что исходный код Qt также был медленно изменен на auto, что повышает эффективность написания кода. Тип данных указывать не нужно. самостоятельно, но позвольте компилятору самостоятельно получить тип данных. Фактически, это не влияет на скорость компиляции компилятора, потому что независимо от того, указан ли тип данных или нет, компилятор должен определить тип данных с правой стороны для оценки. Однако есть недостаток, заключающийся в том, что это влияет на стоимость чтения кода, и во многих случаях вам необходимо самостоятельно разбираться в выводе кода.

173. Класс QUrl необходим для установки или открытия и загрузки локальных файлов в Qt. Рекомендуется добавлять префикс file: /// к локальным файлам.
```cpp
QString url = "file:///c:/1.html";
//Управление браузером для открытия файла локальной веб-страницы
webView->setUrl(QUrl(url));
//Откройте файл локальной веб-страницы одним из следующих двух методов.
QDesktopServices::openUrl(QUrl::fromLocalFile(url));
QDesktopServices::openUrl(QUrl(url, QUrl::TolerantMode));
```

174. Время ожидания часто используется в сетевых запросах, потому что по умолчанию оно составляет 30 секунд. Если вы столкнетесь с сетевым отказом, вам придется долго ждать, чтобы отреагировать. Следовательно, вам необходимо активно установить время ожидания. Если оно превышает, конечный запрос будет напрямую прерван. Встроен начиная с Qt5.15 setTransferTimeout Установить период тайм-аута очень просто.
```cpp
//Частичный цикл событий, не привязанный к основному интерфейсу
QEventLoop eventLoop;

//Установка тайм-аута 5.15 имеет функцию тайм-аута, по умолчанию 30 секунд.
#if (QT_VERSION >= QT_VERSION_CHECK(5,15,0))
manager->setTransferTimeout(timeout);
#else
QTimer timer;
connect(&timer, SIGNAL(timeout()), &eventLoop, SLOT(quit()));
timer.setSingleShot(true);
timer.start(timeout);
#endif

QNetworkReply *reply = manager->get(QNetworkRequest(QUrl(url)));
connect(reply, SIGNAL(finished()), &eventLoop, SLOT(quit()));
eventLoop.exec();

if (reply->bytesAvailable() > 0 && reply->error() == QNetworkReply::NoError) {
    //Прочтите все данные и сохраните их как файл
    QByteArray data = reply->readAll();
    QFile file(dirName + fileName);
    if (file.open(QFile::WriteOnly | QFile::Truncate)) {
        file.write(data);
        file.close();
    }
}
```
175. В Qt существует три основных типа проектов: проект консоли соответствует QCoreApplication, программа традиционного интерфейса QWidget соответствует QApplication, а программа проекта quick / qml соответствует QGuiApplication. Есть много атрибутов, которые необходимо выполнить в верхней части основной функции, чтобы иметь эффект, например, включение поддержки экрана с рекордами, установка режима opengl и т. Д. Для разных типов проектов требуются соответствующие приложения QApplications.
```cpp
//Если это консольная программа, замените QApplication ниже на QCoreApplication
//Если это программа quick / qml, замените QApplication ниже на QGuiApplication
int main(int argc, char *argv[])
{
    //Вы можете использовать следующую строку для тестирования собственного метода ввода Qt qtvirtualkeyboard
    qputenv("QT_IM_MODULE", QByteArray("qtvirtualkeyboard"));
    
    //Настройки не применяют настройки операционной системы, такие как шрифты.
    QApplication::setDesktopSettingsAware(false);

#if (QT_VERSION >= QT_VERSION_CHECK(6,0,0))
    //Установить стратегию округления масштабирования экрана рекордов
    QApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);
#endif
#if (QT_VERSION > QT_VERSION_CHECK(5,6,0))
    //Установите, чтобы включить поддержку масштабирования экрана с высоким разрешением
    //Следует отметить, что расчетная ширина и высота элемента управления или интерфейса могут быть неверными после открытия, все должно быть рассчитано с учетом коэффициента масштабирования.
    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);
    //Установите, чтобы включить поддержку изображения экрана с высоким разрешением
    QApplication::setAttribute(Qt::AA_UseHighDpiPixmaps);
#endif
#if (QT_VERSION > QT_VERSION_CHECK(5,4,0))
    //Установить режим opengl AA_UseDesktopOpenGL (по умолчанию) AA_UseSoftwareOpenGL AA_UseOpenGLES
    //QApplication::setAttribute(Qt::AA_UseSoftwareOpenGL);
    //Установить общий контекст opengl
    QApplication::setAttribute(Qt::AA_ShareOpenGLContexts);
#endif

    QApplication a(argc, argv);
    QWidget w;
    w.show();
    return a.exec();
}
```
176. Чтобы получить параметры конфигурации устройства в QCamera, такие как набор поддерживаемых разрешений и т. Д., Вам необходимо вызвать load, прежде чем его можно будет получить правильно, или определить, является ли состояние ActiveState в связанном сигнале stateChanged, а затем прочитать его. .
```cpp
//Метод 1: получить после вызова load
camera = new QCamera(this);
//Вам нужно сначала загрузить, чтобы получить соответствующие параметры
camera->load();
//Вывести разрешение, поддерживаемое текущим устройством
QList<QSize> sizes = camera->supportedViewfinderResolutions();
emit resolutions(sizes);
//Сбросить разрешение
QCameraViewfinderSettings set;
set.setResolution(cameraWidth, cameraHeight);
camera->setViewfinderSettings(set);
//Удалить после получения
camera->unload();

//Метод 2: получить по сигналу события
camera = new QCamera(this);
connect(camera, SIGNAL(stateChanged(QCamera::State)), this, SLOT(stateChanged(QCamera::State)));
void CameraThread::stateChanged(QCamera::State state)
{
    if (state == QCamera::ActiveState) {
        //Вывести разрешение, поддерживаемое текущим устройством
        QList<QSize> sizes = camera->supportedViewfinderResolutions();
        emit resolutions(sizes);
        //Новое разрешение настройки
        QCameraViewfinderSettings set;
        set.setResolution(cameraWidth, cameraHeight);
        camera->setViewfinderSettings(set);
    }
}

//Когда QCamera не указывает имя устройства, используется камера по умолчанию.
camera = new QCamera(this);
//cameraName = @device:pnp:\\\\?\\usb#vid_046d&pid_0825&mi_00#6&212eebd3&0&0000#{65e8773d-8f56-11d0-a3b9-00a0c9223196}\\global
//Имя устройства (уникальный идентификатор) можно найти через дескриптор устройства.
camera = new QCamera(cameraName.toUtf8(), this);
```

177. Во многих случаях что-то необходимо загрузить при первом отображении формы и только один раз, а не при повторном отображении формы. Почему его нет в конструкторе? Потому что многие вещи можно определить только после того, как они отображаются, например, размер элементов управления и применение некоторых таблиц стилей.
```cpp
void Widget::showEvent(QShowEvent *)
{
    static bool isLoad = false;
    if (!isLoad) {
        isLoad = true;
        //Выполните соответствующую обработку
    }
}
```
179. QDateTime может напрямую форматировать и выводить день недели, а Qt6 по умолчанию выводит на английском языке, например, ddd = вторник, вторник, dddd = вторник, вторник. В настоящее время, если вы хотите всегда быть на китайском языке, вам необходимо использовать QLocale. для преобразования.
```cpp
//Форматированный вывод зависит от языка локальной операционной системы.

//Английская операционная система
//Таким образом получаются трехбуквенные сокращения от понедельника до воскресенья, английского дня недели.
QDateTime::currentDateTime().toString("ddd");
//Вы получаете с понедельника по воскресенье, полные слова недели на английском языке.
QDateTime::currentDateTime().toString("dddd");

//Китайская операционная система
//Таким образом вы получите с понедельника по воскресенье.
QDateTime::currentDateTime().toString("ddd");
//Вы получаете с понедельника по воскресенье.
QDateTime::currentDateTime().toString("dddd");

//Активно указать преобразование языка
//Если местный язык не указан, по умолчанию будет использоваться системный язык.
QLocale locale;
//QLocale locale = QLocale::Chinese;
//QLocale locale = QLocale::English;
//QLocale locale = QLocale::Japanese;

//Следующее всегда выводит китайский с понедельника по воскресенье.
locale.toString(QDateTime::currentDateTime(), "ddd");
//Следующее всегда выводит китайский с понедельника по воскресенье.
locale.toString(QDateTime::currentDateTime(), "dddd");
```
180.QSqlTableModel значительно упрощает отображение, добавление, удаление, изменение и т. Д. Таблиц базы данных, но операция разбиения на страницы базы данных - это небольшой обходной путь.
```cpp
//Создайте экземпляр табличной модели базы данных
QSqlTableModel *model = new QSqlTableModel(this);
//Укажите название таблицы
model->setTable("table");
//Установить сортировку столбца
model->setSort(0, Qt::AscendingOrder);
//Установить режим отправки
model->setEditStrategy(QSqlTableModel::OnManualSubmit);
//Запросить сейчас
model->select();
//Установите модель таблицы базы данных в таблицу
ui->tableView->setModel(model);

//Тест показал, что помимо оператора where в условия фильтрации он также может включать сортировку, ограничение и т. Д.
model->setFilter("1=1 order by id desc limit 100");

//Если в условии фильтра задан оператор сортировки, метод setSort больше не может использоваться
//Результатом следующего кода является ошибка выполнения. Возможно, setSort снова добавил оператор order by, что привело к конфликту нескольких операторов order by.
model->setSort(0, Qt::AscendingOrder);
model->setFilter("1=1 order by id desc limit 100");

//Вы можете установить простой оператор where через setFilter без добавления 1 = 1
model->setFilter("name='Чжан Сан'");
//Если есть другие утверждения, такие как сортировка или ограничение, вам нужно добавить 1 = 1 в начало
//Ниже показана сортировка в порядке возрастания по идентификатору, а результат запроса показывает записи 5–15.
model->setFilter("1=1 order by id asc limit 5,10");

//Свяжите несколько условий с помощью и
//Рекомендуется написать 1 = 1 в начале и добавить; в конце, когда setFilter используется в любое время, чтобы предотвратить правильное выполнение некоторых мест.
model->setFilter("1=1 and name='Чжан Сан' and result>=70;");

//Ниже показано, что имя запроса - это записи Чжан Сана, отсортированные в порядке убывания в соответствии с полем id, а результат - 100 записей, начиная с 10-го элемента, что эквивалентно записям с 10-го по 110-й.
model->setFilter("1=1 and name='Чжан Сан' order by id desc limit 10,100;");

//Добавьте запись в начало строки 3
model->insertRow(2);
//Немедленно заполните новую добавленную строку. По умолчанию она пуста и требует, чтобы пользователь вручную ввел ее в таблицу.
model->setData(model->index(2, 0), 100);
model->setData(model->index(2, 1), "Чжан Сан");
//Отправить обновление
model->submitAll();

//Удалить строку 4
model->removeRow(3);
model->submitAll();

//Короче говоря, после добавления, удаления и изменения операций вам необходимо вызвать model-> submitAll (); для его фактического выполнения, иначе данные будут обновляться только моделью данных и не будут обновлены в базе данных.

//Отменить изменения
model->revertAll();
```
181. Qt родился с Linux и разработан на основе Linux, поэтому многие программисты Qt часто используют Linux в качестве среды разработки, например, обычно используемую ubuntu и другие системы, и разобрали некоторые общие команды Linux.

| Команда | Функция |
| :------ | :------ |
| sudo -s | Переключитесь на администратора, если это sudo -i, текущий каталог будет изменен после переключения. |
| apt install g++ | Установите пакет (требуются права администратора), другая фракция yum install |
| cd /home | Войдите в домашний каталог |
| ls | Список всех каталогов и файлов в текущем каталоге |
| ifconfig | Просмотр информации о сетевой карте, включая IP-адрес, ipconfig в Windows. |
| tar -zxvf bin.tar.gz | Разархивируйте файл в текущий каталог |
| tar -jxvf bin.tar.xz | Разархивируйте файл в текущий каталог |
| tar -zxvf bin.tar.gz -C /home | Разархивируйте файл в каталог / home, не забудьте использовать заглавную C。 |
| tar -zcvf bin.tar.gz bin | Сжать каталог bin в файл формата tar.gz (степень сжатия средняя) |
| tar -jcvf bin.tar.xz bin | Сжать каталог bin в файл формата tar.xz (рекомендуется высокая степень сжатия) |
| tar -... | j z Представляет различные методы сжатия, x представляет собой распаковку, а c представляет сжатие. |
| gedit 1.txt | Откройте текстовый файл с помощью Блокнота |
| vim 1.txt | Используйте vim, чтобы открыть файл. Во многих случаях вы можете сократить его до vi. |
| ./configure  make -j4  make install | Универсальная команда компиляции исходного кода, первый шаг - ./configure для выполнения сценария конфигурации, второй шаг - make -j4, чтобы включить многопоточную компиляцию, и третий шаг - make install для установки скомпилированных файлов.|
| ./configure -prefix /home/liu/Qt-5.9.3-static -static -sql-sqlite -qt-zlib -qt-xcb -qt-libpng -qt-libjpeg -fontconfig -system-freetype -iconv -nomake tests -nomake examples -skip qt3d -skip qtdoc | Общие команды компиляции Qt |
| ./configure -prefix /home/liu/Qt-5.9.3-static -static -release -nomake examples -nomake tests -skip qt3d |  Оптимизация команд компиляции |
| ./configure --prefix=host --enable-static --disable-shared --disable-doc | команда компиляции ffmpeg |

182. Встроенный механизм перенаправления журналов Qt очень прост и удобен в использовании. Поскольку он используется, нет необходимости отлаживать какие-либо точки останова. Он поддерживает qdebug для вывода соответствующей информации, где это необходимо, и вы также можете открыть журнал отладки после программа выпущена. Просмотр вывода и т. д.
```cpp
// Qt5 начал предоставлять вывод контекстной информации журнала, такой как вывод файла кода, в котором находится текущее сообщение печати, номер строки, имя функции и т. Д.
// Если это релиз, вам нужно добавить DEFINES + = QT_MESSAGELOGCONTEXT в pro для вывода контекста.Релиз по умолчанию закрыт.
// Помните, что нельзя писать qdebug и т.п. в функции обработчика журнала, это закончится бесконечным циклом.
// Перенаправление журнала обычно обрабатывается тремя способами
// 1: вывод в файл журнала, например текстовый файл txt.
// 2: хранятся в базе данных, могут быть классифицированы и сохранены, чтобы соответствующий персонал мог запрашивать и анализировать.
// 3: Перенаправление в сеть, после того, как другая сторона подключается к программе с помощью небольшого инструмента, вся информация для печати отправляется через TCP.

//Перенаправление журнала
#if (QT_VERSION >= QT_VERSION_CHECK(5,0,0))
void Log(QtMsgType type, const QMessageLogContext &context, const QString &msg)
#else
void Log(QtMsgType type, const char *msg)
#endif
{
    //Блокировка, чтобы qdebug не слишком часто приводил к сбоям в многопоточном режиме
    static QMutex mutex;
    QMutexLocker locker(&mutex);
    QString content;

    //Здесь вы можете добавлять разные заголовки в соответствии с разными типами, чтобы различать
    switch (type) {
        case QtDebugMsg:
            content = QString("%1").arg(msg);
            break;

        case QtWarningMsg:
            content = QString("%1").arg(msg);
            break;

        case QtCriticalMsg:
            content = QString("%1").arg(msg);
            break;

        case QtFatalMsg:
            content = QString("%1").arg(msg);
            break;
    }

    //Добавьте файл кода, номер строки и имя функции, в которой находится код печати.
#if (QT_VERSION >= QT_VERSION_CHECK(5,0,0))
    if (SaveLog::Instance()->getUseContext()) {
        int line = context.line;
        QString file = context.file;
        QString function = context.function;
        if (line > 0) {
            content = QString("Номер строки:% 1 Файл:% 2 Функция:% 3 \ n% 4").arg(line).arg(file).arg(function).arg(content);
        }
    }
#endif

    //Передайте контент в функцию для обработки
    SaveLog::Instance()->save(content);
}

//Установить ловушку журнала, выводить отладочную информацию в файл, легко отлаживать
void SaveLog::start()
{
#if (QT_VERSION >= QT_VERSION_CHECK(5,0,0))
    qInstallMessageHandler(Log);
#else
    qInstallMsgHandler(Log);
#endif
}

//Удалить ловушку журнала
void SaveLog::stop()
{
#if (QT_VERSION >= QT_VERSION_CHECK(5,0,0))
    qInstallMessageHandler(0);
#else
    qInstallMsgHandler(0);
#endif
}
```
183. Начиная со стандарта C ++ 11, различные синтаксические сахара возникли в бесконечном потоке. Среди них наиболее широко используются лямбда-выражения. В основном, лямбда-выражения поддерживаются с Qt5. Для программистов старшего поколения, привыкших к c99, эта штука в новинку, вот небольшое замечание для понимания.
- Формат кода: [capture](parameters) mutable ->return-type {statement}
- [capture]：Список захвата, список захвата всегда появляется в начале лямбда-функции. Фактически, [] является лидером лямбда. Компилятор определяет, является ли следующий код лямбда-функцией на основе лидера. Список захвата может захватывать переменные в контексте.Используется лямбда-функциями.
- (parameters)：Список параметров соответствует списку параметров обычных функций.Если передача параметра не требуется, ее можно опустить вместе с круглыми скобками ().
- mutable：mutable Модификатор, по умолчанию лямбда-функция всегда является константной функцией, а mutable может отменить ее постоянство. При использовании этого модификатора список параметров нельзя пропустить (даже если параметр пуст).
- ->return-type：Тип возврата, объявите тип возвращаемого значения функции в виде типа возврата трассировки, мы можем опустить его вместе с символом ->, когда нам не нужно возвращаемое значение. Кроме того, если тип возвращаемого значения ясен, вы также можете опустить эту часть и позволить компилятору определить тип возвращаемого значения.
- {statement}：Тело функции имеет то же содержимое, что и обычная функция, но в дополнение к параметрам также могут использоваться все захваченные переменные.

Список захвата имеет следующие формы:
- [var] указывает, что метод передачи значения захватывает переменную var.
- [=] означает, что метод передачи значения захватывает все переменные родительской области (включая эту).
- [& var] означает передачу по ссылке для захвата переменной var.
- [&] означает захват всех переменных родительской области (включая эту) по ссылке.
- [this] указывает, что метод передачи значения захватывает текущий указатель this.

```cpp
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    //Нажатие кнопки без параметров
    connect(ui->pushButton, &QPushButton::clicked, [] {
        qDebug() << "hello lambda";
    });

    //Нажатие кнопки с параметрами
    connect(ui->pushButton, &QPushButton::clicked, [] (bool isCheck) {
        qDebug() << "hello lambda" << isCheck;
    });

    //Пользовательский сигнал с параметрами
    connect(this, &MainWindow::sig_test, [] (int i, int j) {
        qDebug() << "hello lambda" << i << j;
    });

    emit sig_test(5, 8);
}
```

184. Из-за большого количества версий Qt, иногда для совместимости с несколькими версиями или даже для охвата совместимости с Qt4 / Qt5 / Qt6, некоторые файлы заголовков или имена классов были изменены или добавлены, и оценка версии Qt должна быть использовал. Следует отметить, что если вы используете QT_VERSION_CHECK в файле заголовка, вам необходимо ввести #include «qglobal.h», иначе компиляция завершится неудачно, потому что функция QT_VERSION_CHECK находится в файле заголовка qglobal.h.
```cpp
//Должен быть включен как минимум qglobal.h. Теоретически все классы Qt включают этот файл заголовка, поэтому вы также можете включить другие файлы заголовков для Qt, такие как qobject.h
#include "qglobal.h"
#if (QT_VERSION >= QT_VERSION_CHECK(5,0,0))
#include "qscreen.h"
#else
#include "qdesktopwidget.h"
#endif
```
185. При использовании QString для преобразования в char * или const char * не забудьте выполнить его в два шага, урок крови, в одной сцене, потому что нет двух шагов, феномен заключается в том, что отладочный ненормальный выпуск msvc нормально, mingw и отладка и выпуск gcc нормальны, что очень безмолвно, долго ищет проблемы, метод устранения контрастного метода приемлем или есть проблемы.
-До конвертации содержимое QString не имеет ничего общего с китайским или английским, проблемы те же.
-QByteArray не имеет ничего общего с конкретным типом в преобразовании, такие методы, как toUtf8, toLatin1, toLocal8Bit, toStdString и т. Д., Имеют те же проблемы.
-После преобразования неважно, char * или const char *, проблема та же.
-Случайность проблемы, вероятность появления, теоретически вероятность отладки больше.
-Согласно анализу крутого босса кода, возможная причина (не уверен) в том, что msvc, чтобы облегчить отладку, будет заполнять память после того, как он будет выпущен, но не когда он будет выпущен.
```cpp
QString text = "xxxxx";
//Следующее преобразование может быть проблематичным
char *data = text.toUtf8().data();
//Преобразование в два этапа не вызовет проблем
QByteArray buffer = text.toUtf8();
char *data = buffer.data();
const char *data = buffer.constData();
```
186. Вопрос о том, использовать ли QList или QVector всегда был вопросом выбора для многих Qter, в основном потому, что функции интерфейса, предоставляемые этими двумя гаджетами, в основном одинаковы, такие как вставка, удаление и значение.
-QList можно использовать в большинстве случаев. Для таких операций, как добавление, добавление и вставка, QList обычно намного быстрее, чем QVector.
-QList основан на индексном теге для хранения своих элементов в памяти, что быстрее, чем итерация итератора, и у вас меньше кода.
-Если вам нужен реальный подключенный список, и вам нужно обеспечить фиксированное время вставки. Затем используйте итераторы вместо тегов. Используйте QLinkedList ().
-Если вам нужно открыть непрерывное пространство памяти для хранения, или ваш элемент намного больше, чем указатель, вам нужно избегать отдельных операций вставки и переполнения стека, используйте QVector в это время.
-Если вас больше беспокоит скорость выборки значений, используйте QVector.QCustomPlot использует QVector, и вам нужно часто извлекать большой объем данных для построения графика.
-Если вас больше беспокоит скорость обновления данных (добавление, удаление и т. Д.), Используйте QList (соответствующая операция [] = value), но поскольку QChart в основном использует QList для доступа к данным (соответствующая операция находится в ()) , это также приводит к большим данным. Одна из причин медленного измерения подверглась критике.
-В основном, как правило, график кривой - это доступ к данным, получение установленных данных для рисования.
- При небольшом объеме данных между ними почти нет разницы в производительности.
-Похоже, что Qt6 объединил эти два класса (Qter, который трудно выбрать, освобожден), QVector = QList, то есть QVector является псевдонимом QList, и базовый код может быть изменен, чтобы использовать преимущества двух .

187. о mouseTracking Отслеживание мыши и tabletTracking Некоторые официальные инструкции по отслеживанию планшета.
- mouseTracking Атрибут используется, чтобы сохранить, включено ли отслеживание мыши, и он не включен по умолчанию.
- Если он не включен, соответствующий компонент принимает события движения мыши только тогда, когда во время движения мыши нажимается хотя бы одна кнопка мыши.
- Когда отслеживание мыши включено, любой виджет событий движения мыши получит.
- Компонентный метод hasMouseTracking() Используется для определения того, включено ли отслеживание мыши в данный момент.
- setMouseTracking(bool enable) Используется для установки, следует ли включать отслеживание мыши.
- Функции, связанные с отслеживанием мыши, в основном mouseMoveEvent()。
- tabletTracking Атрибут сохраняет, следует ли включать отслеживание детали на планшете. По умолчанию не используется.
- Когда отслеживание планшета не включено, компонент будет получать события движения пера только тогда, когда перо касается планшета или нажата хотя бы одна кнопка пера.
- Если для компонента включена функция отслеживания планшета, компонент может получать событие движения стилуса, когда стилус приближается, но фактически не касается планшета.
- Это может использоваться для контроля рабочего положения и вспомогательных рабочих функций компонентов (таких как поворот и наклон), а также для предоставления информационного интерфейса для этих операций для графического интерфейса.
- Компонентный метод hasTabletTracking() Используется для определения того, включено ли отслеживание планшета в данный момент.
- setTabletTracking(bool enable) Используется для настройки включения отслеживания планшета.
- Функции, связанные с отслеживанием планшетов, в основном tabletEvent()。

188. Что касается QTableWidget и других элементов управления, вызовите встроенные функции removeRow, clearContents и clear для удаления элемента и содержимого внутри и автоматически вызовите деструктор элемента или виджета ячейки для освобождения ресурсов, не освобождая его вручную.
```cpp
//Каждый вызов clearContents автоматически очищает предыдущий элемент
ui->tableWidget->clearContents();
for (int i = 0; i < count; ++i) {
    ui->tableWidget->setItem(i, 0, new QTableWidgetItem("aaa"));
    ui->tableWidget->setItem(i, 1, new QTableWidgetItem("bbb"));
    ui->tableWidget->setCellWidget(i, 2, new QPushButton("ccc"));
}
```

189. Для QListView (QListWidget), QTreeView (QTreeWidget), QTableView (QTableWidget) этого типа элемента управления вы можете использовать setChecked, чтобы соответствующий элемент имел эффект флажка. Многие люди (в том числе они сами) ошибочно думают, что это флажок. Этого элемента управления, на самом деле, нет. Это индикатор соответствующего элемента управления, поэтому, если вы хотите изменить стиль, вы не можете сказать, что установка стиля QCheckBox будет иметь эффект, но вам нужно выровнять индикатор индикатор отдельно, чтобы установить стиль.
```cpp
QCheckBox::indicator,QGroupBox::indicator,QTreeWidget::indicator,QListWidget::indicator{
width:13px;
height:13px;
}

QCheckBox::indicator:unchecked,QGroupBox::indicator:unchecked,QTreeWidget::indicator:unchecked,QListWidget::indicator:unchecked{
image:url(:/qss/flatwhite/checkbox_unchecked.png);
}

QCheckBox::indicator:unchecked:disabled,QGroupBox::indicator:unchecked:disabled,QTreeWidget::indicator:unchecked:disabled,QListWidget::indicator:disabled{
image:url(:/qss/flatwhite/checkbox_unchecked_disable.png);
}

QCheckBox::indicator:checked,QGroupBox::indicator:checked,QTreeWidget::indicator:checked,QListWidget::indicator:checked{
image:url(:/qss/flatwhite/checkbox_checked.png);
}

QCheckBox::indicator:checked:disabled,QGroupBox::indicator:checked:disabled,QTreeWidget::indicator:checked:disabled,QListWidget::indicator:checked:disabled{
image:url(:/qss/flatwhite/checkbox_checked_disable.png);
}

QCheckBox::indicator:indeterminate,QGroupBox::indicator:indeterminate,QTreeWidget::indicator:indeterminate,QListWidget::indicator:indeterminate{
image:url(:/qss/flatwhite/checkbox_parcial.png);
}

QCheckBox::indicator:indeterminate:disabled,QGroupBox::indicator:indeterminate:disabled,QTreeWidget::indicator:indeterminate:disabled,QListWidget::indicator:indeterminate:disabled{
image:url(:/qss/flatwhite/checkbox_parcial_disable.png);
}
```

190. Что касается QTableView (с использованием источника данных модели), имени столбца QTableWidget и настроек ширины столбца, иногда обнаруживалось, что он не работает. Оказывается, существуют требования к порядку настроек кода. Например, setColumnCount должен быть установлен перед setColumnWidth, в противном случае нет количества столбцов. Откуда появился столбец? Wide, включая setHorizontalHeaderLabels для установки коллекции заголовков столбца, в помещении должен быть столбец первым.
```cpp
void frmSimple::initForm()
{
    //Создание экземпляра модели данных
    model = new QStandardItemModel(this);

    //Установите количество строк и столбцов
    row = 100;
    column = 10;
    //Установить ширину столбца имени столбца
    for (int i = 0; i < column; ++i) {
        columnNames << QString("列%1").arg(i + 1);
        columnWidths << 60;
    }
}

void frmSimple::on_btnLoad1_clicked()
{
    //Сначала установите модель данных, иначе setColumnWidth не будет работать
    ui->tableView->setModel(model);

    //Установите количество столбцов, заголовки столбцов и ширину столбцов.
    model->setColumnCount(column);
    //Простой способ настроить коллекцию заголовков столбцов
    model->setHorizontalHeaderLabels(columnNames);
    for (int i = 0; i < column; ++i) {
        ui->tableView->setColumnWidth(i, columnWidths.at(i));
    }

    //Добавить строки данных в цикл
    QDateTime now = QDateTime::currentDateTime();
    model->setRowCount(row);
    for (int i = 0; i < row; ++i) {
        for (int j = 0; j < column; ++j) {
            QStandardItem *item = new QStandardItem;
            //Последний столбец показывает разницу во времени.
            if (j == column - 1) {
                item->setText(now.addSecs(i).toString("yyyy-MM-dd HH:mm:ss"));
            } else {
                item->setText(QString("%1_%2").arg(i + 1).arg(j + 1));
            }
            model->setItem(i, j, item);
        }
    }
}

void frmSimple::on_btnLoad2_clicked()
{
    //Установите заголовок столбца, количество столбцов и ширину столбца
    ui->tableWidget->setColumnCount(column);
    //Простой способ настроить коллекцию заголовков столбцов
    ui->tableWidget->setHorizontalHeaderLabels(columnNames);
    for (int i = 0; i < column; ++i) {
        ui->tableWidget->setColumnWidth(i, columnWidths.at(i));
    }

    //добавление данных
    QDateTime now = QDateTime::currentDateTime();
    ui->tableWidget->setRowCount(row);
    for (int i = 0; i < row; ++i) {
        for (int j = 0; j < column; ++j) {
            QTableWidgetItem *item = new QTableWidgetItem;
            //Последний столбец показывает разницу во времени.
            if (j == column - 1) {
                item->setText(now.addSecs(i).toString("yyyy-MM-dd HH:mm:ss"));
            } else {
                item->setText(QString("%1_%2").arg(i + 1).arg(j + 1));
            }
            ui->tableWidget->setItem(i, j, item);
        }
    }
}
```
191. Что касается обработки очереди QList, наиболее часто используемой является вызов функции добавления для добавления элемента и вставки элемента вперед. Первое впечатление многих людей - это вызов insert (0, xxx) для вставки. Фактически, QList полностью предоставляет функцию prepend для добавления элемента вперед., Push_front.
```cpp
QStringList list;
list << "aaa" << "bbb" << "ccc";

//Добавить позже эквивалентно добавлению
list.push_back("ddd");
//Добавить вперед эквивалентно добавлению в начало
list.push_front("xxx");

//Добавить позже
list.append("ddd");
//Добавить вперед
list.prepend("xxx");

//Указание первой позиции для вставки эквивалентно добавлению в начало
list.insert(0, "xxx");

//Вывод QList("xxx", "aaa", "bbb", "ccc", "ddd")
qDebug() << list;
```
192. Qt имеет несколько встроенных типов, связанных с QList, QMap и QHash, которые можно использовать напрямую, без написания длинного типа самостоятельно.
```cpp
//qwindowdefs.h
typedef QList<QWidget *> QWidgetList;
typedef QList<QWindow *> QWindowList;
typedef QHash<WId, QWidget *> QWidgetMapper;
typedef QSet<QWidget *> QWidgetSet;

//qmetatype.h
typedef QList<QVariant> QVariantList;
typedef QMap<QString, QVariant> QVariantMap;
typedef QHash<QString, QVariant> QVariantHash;
typedef QList<QByteArray> QByteArrayList;
```

193. Интервал полей макета Qt, если он не был изменен, будет определять соответствующее значение по умолчанию в соответствии с системным разрешением и изменяемым коэффициентом масштабирования. Например, разрешение 1080P составляет 9 пикселей, а разрешение 2K - 9 пикселей. . Он становится 11 пикселей. Все программы, которые вы найдете на компьютере 1080P, имеют размер 6 и 9 пикселей. Как могут интервалы и поля стать такими большими при разрешениях 2K и 4K? Если вы хотите сохранить их независимо от того, какие разрешения все равно , вам нужно вручную сбросить эти значения, есть яма, например, по умолчанию 9, вы хотите, чтобы другие разрешения были 9, вы должны сначала изменить 9 на другие значения, такие как 10, а затем изменить на 9. Таким образом, это означает реальное изменение. Если вы измените 9 на 9 напрямую, оно не изменится. В правой части конструктора свойств есть небольшая стрелка для восстановления значения, она также серая. Только когда дисплей затемняется и появляется стрелка для восстановления значения по умолчанию. Указывает, что вы действительно изменили значение.

### 2. Обновитесь до Qt6
#### 2.1 Интуитивное резюме
1. Было добавлено много колес, а исходные модули разбиты более детально, что, по оценкам, облегчит расширение управления.
2. Удалены некоторые излишне инкапсулированные вещи (например, для одной и той же функции есть несколько функций), чтобы гарантировать, что только одна функция выполняет эту функцию.
3. Некоторые методы, совместимые с Qt4 в Qt5, отбрасываются, и должны использоваться соответствующие новые функции в Qt5.
4. Следуя по стопам времени, было добавлено много новых функций для удовлетворения постоянно растущих потребностей клиентов.
5. Революционная переработка определенных модулей и типов и обработки повысила эффективность работы.
6. Изменены типы параметров, такие как long * на qintptr * и т. Д., Которые больше подходят для последующего расширения и совместимости с 32 64-битными системами.
7. Все типы данных double в исходном коде заменены на qreal, который очень согласован и единообразен с внутренними типами данных Qt.
8. Я тестировал часть QWidget, но быстрая часть не тестировалась. Предполагается, что в быстрой части может быть больше обновлений.
9. Настоятельно рекомендуется пока не использовать версию между Qt6.0 и Qt6.2, некоторые модули все еще отсутствуют, условно говоря, ошибок больше, и для начала официальной миграции рекомендуется версия 6.2.

194. Универсальный метод: установите версию 5.15, найдите функцию сообщения об ошибках, переключитесь на исходный файл док-станции, вы увидите соответствующие слова подсказки QT_DEPRECATED_X («Use sizeInBytes») и новую функцию. Модификация в соответствии с этой подсказкой является правильной. Некоторые функции были недавно добавлены из Qt5.7, 5.9, 5.10 и других версий. Возможно, ваш проект все еще использует метод Qt4, но Qt6 уже совместим с этими старыми методами, и вам нужно его использовать полностью, когда вы достигнете нового метода Qt6.
195. Базовый класс Qt6 разделен на ядро, и добавлен core5compat, поэтому вам нужно добавить соответствующий модуль в pro и ввести соответствующий файл заголовка в код.
```cpp
//pro Модуль импорта файлов
greaterThan(QT_MAJOR_VERSION, 4): QT += widgets
greaterThan(QT_MAJOR_VERSION, 5): QT += core5compat

//Добавьте заголовочные файлы в код
#if (QT_VERSION >= QT_VERSION_CHECK(5,0,0))
#include <QtWidgets>
#endif
#if (QT_VERSION >= QT_VERSION_CHECK(6,0,0))
#include <QtCore5Compat>
#endif
```
196. По умолчанию в Qt6 включена поддержка экрана рекордов, интерфейс станет очень большим, и даже шрифт будет блеклым.Многие люди не будут к нему привыкать, потому что в этом режиме, если программа не использует devicePixelRatio для многих координат расчеты, 100% будет странно.Проблема в том, что координаты неточные. Чтобы отменить этот эффект, вы можете установить коэффициент масштабирования экрана с высоким разрешением.
```cpp
#if (QT_VERSION >= QT_VERSION_CHECK(6,0,0))
    QGuiApplication::setHighDpiScaleFactorRoundingPolicy(Qt::HighDpiScaleFactorRoundingPolicy::Floor);
#endif
```
197. Исходная функция случайных чисел предлагает заменить на QRandomGenerator. Для обеспечения совместимости со всеми версиями qt минимальным изменением является прямое использование случайного числа в C ++, например замена функции qsrand на srand и qrand на rand. После при просмотре исходного кода он фактически инкапсулирован. Это случайное число в C ++, многие похожие пакеты, такие как sin, упакованы qSin.
198. Свет QColor меняется на более светлый, а темный - на более темный Фактически, два метода более светлого и темного всегда существовали раньше.
199. Fm.width в QFontMetricsF заменяется на fm.horizontalAdvance, и новая функция используется начиная с 5.11.
200. Значение перечисления палитры QPalette, Foreground = WindowText, Background = Window, где Foreground и Background пропали, вы должны вместо этого использовать WindowText и Window, как это было раньше. Точно так же setTextColor был изменен на setForeground.
201. Измените delta () QWheelEvent на angleDelta (). Y () и измените pos () на position ().
202. Модуль svg разделяет svgwidgets. Если вы используете этот модуль, вам нужно добавить QT + = svgwidgets в pro. Точно так же модуль opengl разделяет openglwidgets.
203. Функция margin () в qlayout заменена на contentMargins (). Left (). Глядя на исходный код, мы знаем, что предыдущая функция margin () возвращает contentsMargins (). Left (). Когда четыре значения совпадают , по умолчанию четыре значения одинаковы. Аналогичным образом был удален setMargin, и для всех используется setContentsMargins.
204. Перед QChar c = 0xf105 все должно быть изменено на принудительное преобразование QChar c = (QChar) 0xf105, больше не будет неявного преобразования, иначе компилятор сообщит об ошибке: преобразование из int в QChar неоднозначно.
205. qSort Подождите, пока некоторые функции будут использовать C ++  std::sort 。
```cpp
#if (QT_VERSION >= QT_VERSION_CHECK(6,0,0))
    std::sort(ipv4s.begin(), ipv4s.end());
#else
    qSort(ipv4s);
#endif
```
206. Qt :: WA_NoBackground заменяется на Qt :: WA_OpaquePaintEvent.
207. Класс QMatrix заброшен и заменен на QTransform.Функции в основном те же.Класс QTransform всегда был доступен в Qt4.
208. Таймер QTime был удален и должен быть изменен на QElapsedTimer.Класс QElapsedTimer всегда был доступен в Qt4.
209. QApplication::desktop() Заброшен, заменен QApplication::primaryScreen()。
```cpp
#if (QT_VERSION > QT_VERSION_CHECK(5,0,0))
#include "qscreen.h"
#define deskGeometry qApp->primaryScreen()->geometry()
#define deskGeometry2 qApp->primaryScreen()->availableGeometry()
#else
#include "qdesktopwidget.h"
#define deskGeometry qApp->desktop()->geometry()
#define deskGeometry2 qApp->desktop()->availableGeometry()
#endif
```
210. Получение текущего индекса экрана и размера необходимо обрабатывать отдельно.
```cpp
//Получить текущий индекс экрана
int QUIHelper::getScreenIndex()
{
    //Необходимо обработать несколько экранов
    int screenIndex = 0;
#if (QT_VERSION >= QT_VERSION_CHECK(5,0,0))
    int screenCount = qApp->screens().count();
#else
    int screenCount = qApp->desktop()->screenCount();
#endif

    if (screenCount > 1) {
        //Найдите экран, на котором находится текущая мышь
        QPoint pos = QCursor::pos();
        for (int i = 0; i < screenCount; ++i) {
#if (QT_VERSION >= QT_VERSION_CHECK(5,0,0))
            if (qApp->screens().at(i)->geometry().contains(pos)) {
#else
            if (qApp->desktop()->screenGeometry(i).contains(pos)) {
#endif
                screenIndex = i;
                break;
            }
        }
    }
    return screenIndex;
}

//Получить область текущего размера экрана
QRect QUIHelper::getScreenRect(bool available)
{
    QRect rect;
    int screenIndex = QUIHelper::getScreenIndex();
    if (available) {
#if (QT_VERSION >= QT_VERSION_CHECK(5,0,0))
        rect = qApp->screens().at(screenIndex)->availableGeometry();
#else
        rect = qApp->desktop()->availableGeometry(screenIndex);
#endif
    } else {
#if (QT_VERSION >= QT_VERSION_CHECK(5,0,0))
        rect = qApp->screens().at(screenIndex)->geometry();
#else
        rect = qApp->desktop()->screenGeometry(screenIndex);
#endif
    }
    return rect;
}
```
211. Класс QRegExp был перемещен в модуль core5compat, и необходимо активно внедрить заголовочный файл #include <QRegExp>.
```cpp
    //Установите ограничение на ввод только цифр + десятичных знаков
    QString pattern = "^-?[0-9]+([.]{1}[0-9]+){0,1}$";
    //Установить фильтр проверки IP-адреса
    QString pattern = "(2[0-5]{2}|2[0-4][0-9]|1?[0-9]{1,2})";

    //Если быть точным, QRegularExpression QRegularExpressionValidator доступен с 5.0 5.1.
#if (QT_VERSION >= QT_VERSION_CHECK(6,0,0))
    QRegularExpression regExp(pattern);
    QRegularExpressionValidator *validator = new QRegularExpressionValidator(regExp, this);
#else
    QRegExp regExp(pattern);
    QRegExpValidator *validator = new QRegExpValidator(regExp, this);
#endif
    lineEdit->setValidator(validator);
```
212. Изменились параметры построения QWheelEvent и соответствующая функция ориентации вычислений.
```cpp
//Имитировать колесо мыши
#if (QT_VERSION < QT_VERSION_CHECK(6,0,0))
QWheelEvent wheelEvent(QPoint(0, 0), -scal, Qt::LeftButton, Qt::NoModifier);
#else
QWheelEvent wheelEvent(QPointF(0, 0), QPointF(0, 0), QPoint(0, 0), QPoint(0, -scal), Qt::LeftButton, Qt::NoModifier, Qt::ScrollBegin, false);
#endif
QApplication::sendEvent(widget, &wheelEvent);

//Непосредственно изменить значение с помощью колесика мыши
QWheelEvent *whellEvent = (QWheelEvent *)event;
//Угол прокрутки, * 8 - это расстояние прокрутки мыши
#if (QT_VERSION < QT_VERSION_CHECK(6,0,0))
int degrees = whellEvent->delta() / 8;
#else
int degrees = whellEvent->angleDelta().x() / 8;
#endif
//Количество шагов прокрутки, * 15 - угол прокрутки мыши
int steps = degrees / 15;
```
