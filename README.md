# Qt-Advices

Перевод советов от китайца
https://github.com/andr1312e/Qt-Advices/tree/main/feiyangqingyun#readme

гугл стайл чистого кода
https://evgenykislov.com/wp-content/custom/cpp_codestyle/cppguide_ru.html
Еще один гугл гайд
https://netvl.github.io/guice/users-guide.html

Russian qt advices советы кути русский по русски рекомендации кутэ

КОРЕ
ЧИСЛА

1. Использовать ```qAbs``` или его std варинт надо с большой острожностью. Например строки:
```cpp
      int distance = 2000;
      const int distDiff = distance - ustirovRep.GetNormalMessage().Distance;\\quint32
      const int diff = qAbs(distDiff);
```
Дает при distDiff=-1 в diff результат 1
А вот 
```cpp
      int distance = 2000;
      const int diff = qAbs(distance - ustirovRep.GetNormalMessage().Distance);
```
в diff дает -1;

<details>
  <summary>Скришнот</summary>
      
  ![image](https://user-images.githubusercontent.com/22058642/181718798-6a7f5f8b-2e07-4379-ba88-9e3653be24e5.png)

</details>
СТРОКИ

1. Проблема со строковыми классами ```QString``` в целом заключается в том, что они копируют содержимое  char* при их создании. ```QByteArray``` представляет собой последовательность байтов без какой-либо кодировки, поэтому ее можно
рассматривается как эквивалент ```std::string```. Используйте аррей для хранения байтовых массивов. Его конструкторы будут брать внутренний буфер и копировать его. Если мы хотим избежать этой копии, мы можем использовать функцию ```fromRawData()```,
который будет хранить только указатель на данные, но не станет владельцем.
Вызывающий обьект должен гарантировать, что указанные данные остаются действительными для всего времени жизни ```QByteArray```. Другой возможностью является использование макроса ```QByteArrayLiteral()```. Этот макрос будет
генерить QByteArray из литерала char* во время компиляции и поместит его в сегмент памяти только для чтения.
2. ```QString``` представляет строку Unicode в кодировке UTF-16 и поддерживает кодировку Unicode. Он неявно используется совместно (подсчет ссылок), и его конструкторы будут выделять
объем памяти один раз. Аналогично ```QByteArray```, если мы хотим сэкономить выделения памяти, мы можем использовать  ```fromRawData()``` функцию или макрос ```QStringLiteral()``` аналогично.
Существует дополнительный строковый класс под названием ```QLatin1String```, который обеспечивает тонкую оболочку вокруг ASCII-закодированных литералов char*. Он подразумевается как
оптимизация, чтобы избежать построения объекта ```QString```. Однако русская кириллица не поддерживается.Так как этот класс не является строкой Unicode, она будет использовать половину памяти эквивалентного
```QString```.
3.  Qt предоставляет  класс, называемый ```QStringBuilder```, обеспечивающий базовую оптимизацию  для конкатенации ```QString```. Этот класс не предназначен для создания экземпляров
напрямую, но будет автоматически вызываться, когда его перегруженный оператор % используется вместо обычного оператора конкатенации +, как в следующем примере:

```cpp
QString s1("Привет");
QLatin1String s2 («вы все»);
QString msg = s1 % s2 % "как дела?";
```
Установив глобальную опцию ```QT_USE_STRING_BUILDER```, оператор конкатенации + всегда будет автоматически заменяться классом шаблона QStringBuilder, и вам не нужно вручную изменять код, чтобы извлечь из этого пользу.

```cpp
DEFINES +=                 \
  DQT_NO_URL_CAST_FROM_STRING\
  QT_USE_STRING_BUILDER \
```

4. В Qt 4 уже был класс, инкапсулирующий подстроки заданной строки, с именем ```QStringRef```. Он не хранит никаких данных, кроме указателей на часть ```QString```. Таким образом, подстроки могут быть дешево переданы без выделения новой памяти. Пример этого класса:
```
QString s("альфа, бета, гамма, дзета");
QVector<QStringRef> alfaBet = s.splitRef(", "); // вместо split()!
```
Однако в Qt 5.10 был введен новый класс для представления подстрок, а именно класс ```QStringView```, созданный по образцу C++17 ```std::string_view```. Разница между этими двумя классами в том, что ```QStringRef``` требует ```QString```
экземпляр в качестве источника, в то время как QStringView обеспечивает представление произвольного UTF-16 как из строк, так и строкового литерала. Из-за разной реализации и урезаного функционала, ``QStringRef`` устарел и вырезан в 6 версии. 

5. Многие знают, что все строки с одинаковым содержимым разделяют одну и ту же память. Это круто, потому что экономит место, но также позволяет быстро сравнивать строки на равенство путем сравнения только указателей. Реализация довольно проста, пример на чистом с++
```cpp
template <char... String> struct Interned
{
static constexpr char const value[sizeof...(String) + 1]{String...};
};
template <char... String> constexpr char const Interned<String...>::value[];

template<typename CharT, CharT ...String>
constexpr const char* operator""_intern()
{
return (Interned<String...>::value);
}
// test: only one copy?
static_assert("foo"_intern == "foo"_intern, ""); 
```
GCC скомпилирует этот код только в режиме C++14 и выше! Литерал char* упаковывается в тип и представляется указатель на (один и единственный) статический член типа-оболочки.  Интернирование — всего лишь один из вариантов классического шаблона проектирования Gang of Four (GoF) Приспособленец. Этот шаблон определяет легковесные прокси, которые избегают дублирования часто используемых объектов, собственно, чего мы хотим достичь с интернированием. Библиотека ```Boost.Flyweight``` реализует этот шаблон тоже, и мы могли бы использовать его со стандарными строками следующим образом: ```boost::flyweight<std::string>```.

6. Когда в вашей программе преобладает поиск подстрок, то разумно использовать новые алгоритмы, один из которых уже добавлен в C++17 . Речь идет об алгоритме [Бойера-Море-Хорспула](https://habr.com/ru/post/116725/), который часто работает быстрее стандартного stl-поиска. Этот алгоритм не проверяет каждый символ строки, пытается пропустить некоторые из них, используя таблицу, сгенерированную из строки. Посмотрите на следующий пример его использования: 
```cpp
QString text = "Lorem ipsum dolor sit amet, consectetur adipiscing ...";
QString needle ="amet";
auto iter = std::search(text.constBegin(), text.constEnd(),
std::boyer_moore_searcher(
needle.constBegin(), needle.constEnd()));
```
В 11 версии с++ мы можем использовать ```Boost``` реализацию ```Boyer-More-Horspool``` алгоритм поиска строки. Как всегда у причудливых алгоритмов есть цена в виде создания строковой таблицы, поэтому этот алгоритм принесет улучшения производительности только для больших строк. 

7. Если мы хотим избежать выделения памяти, мы могли бы просто использовать const char*,  в стиле C. Однако это не очень удобно. К счастью, библиотека стандартных шаблонов EASTL, содержит фиксированный размер строк, который не будет выделять дополнительную память, а именно ```eastl::fixed_string```. Вы можете установить максимальный объем памяти, который будет используется, а для критических случаев также может быть включено динамическое распределение. Мы могли бы также использовать ```QStringLiteral``` для строки фиксированного размера. [статья про литерал](https://www.pvsm.ru/c-3/8497)

8. Просто опять же история в том что надо честно посмотреть самому себе в глаза и ответить на вопрос.. а все ли остальное настолько офигенно и оптимально в моем коде алгоритмически что начать переживать из-за контейнеров строк..QString это честная и да сложная по своей организации _текстовая_ абстракция решающая огромный спектр задач, но именно это и нужно в 99% случаях когда речь идет о строках

9. Ну тому же QString аналога в STL в общем-то нет
Но, в отличие от, например, юникодной стринги раста (https://doc.rust-lang.org/std/string/struct.String.html), QString плох использованием UTF-16 (https://doc.qt.io/qt-6/qstring.html#details)

АЛГОРИТМЫ

1. Основное правило оптимизации любого алгоритма можно сформулировать так: «Не повторяйте себя", а точнее, "Не повторяйте вычислений". Вы можете сделать это в несколько
способами, например:
 * Пропуск работы с использованием знаний о структуре задачи: Для например, разделить задачу на подзадачи и объединить результаты используя уже готовые данные. Мы стремимся к линейным или логарфмическим алгоритмам. Итак, если у вас есть двойной цикл (и, следовательно, сложность O (n^2)) то, лучше бы он не возникал на критическом пути! С большими входными данными даже алгоритм O(n) может выполняться довольно медленно.
 * Например, не вычисляйте факториалы, а найдите их в таблице. Или, сохраните вычисленные результаты для последующего использования (например, для кэширования или запоминания, чаще всего в программах страдает не обьем памяти а именно производительность, поэтому в большистве случаев, лучше пожертвовать первым чем вторым. Отличным примером сохранения результатов для экономии времени является преобразование Шварца  ``Schwartzian transform``, известное из Perl.
 * Есть еще одна интересная техника, которую мы могли бы использовать, а именно: Использование 2 путей: короткого и  более медленного в качестве запасного варианта. Если короткий путь, который работает точно, но в большинстве случаев. Одним из интересных примеров такого подхода является использование фильтра Блума. Фильтр Блума — это компактная вероятностная структура данных, которая сохраняет информацию о членстве в наборе. Поскольку он вероятностный, это означает, что мы можем получить ложный ответ, Блум фильтры могут лгать нам только тогда, когда говорят, что элемент находится в наборе. Если алгоритм говорит элемент не содержится, это гарантированно верно. Итак, зачем использовать структуру данных, которая работает в половине случаев? Причина в том, что тест очень быстрый, нет, он очень-очень быстрый, и  работает с большим количеством элементов. Итак, мы сначала проверяем, есть ли элемент (Блумом), и если нет, мы закончили — есть быстрый путь. Если фильтр говорит, что элемент содержится, мы должны проверить его с помощью медленного алгоритма, правда ли он есть там.  Возьмите на вооружение эвристику: эвристика — это практичный метод, 
быть достаточным для достижения поставленной цели, не оптимальным или даже не логичным. 
 * Возможно, вы слышали о NP-полных задачах. Это алгоритмы с безумно высокими вычислительными сложностями, для которых нет хороших решений, известных на сегодня. Тем не менее, такие проблемы могут быть решены на практике с помощью эвристики.
 * Однако причудливые алгоритмы могут иметь высокую стоимость (например, накладные расходы на инициализацию), как мы видели ранее в случае Бойера. Еще одним недостатком алгоритмов является поиск ошибок в них, и разбор их другими программистами.
2. Когда дело доходит до структур данных, есть один основной совет: Выберите подходящую структуру данных для вашей задачи. Вы сделаете это, посмотрев на свой шаблон использования и выбрав данные структура с лучшей скоростью для операций, которые вам нужны. Две наиболее удобные для производительности структуры данных - это массивы для хранения простого объекта или примитивов и хеш-таблицы для поиска по ключу. Древовидные структуры также имеют свое место, но скорее предназначены для более специализированного использования. Списки, конечно, тоже можно использовать, но не в коде, критичным к производительности.
3. Еще  один неочевидный подход в оптимизации заключается в том сто бы использовать вместо:
```cpp
struct Data { ObjA a; ObjB b; int x };
std::vector<Data> myData;
```
Следующий код:
```cpp
struct Data
{
std::vector<ObjA> a;
std::vector<ObjB> b;
std::vector<int> x;
} myData;
```
Как ни странно для новичков, но 2 код работает гораздо быстрее чем первый, особенно для сложных обьектов, но не для указателей!
Заменяется один массив полиморфных указателей на объекты на большую специальная графовая структура из них с несколькими массивами, по одному для каждого
конкретный тип статического объекта. Зачем:
* Во-первых, мы избавляемся от полиморфизма, избавляя нас от косвенности vtable
* Вручную обеспечивается хорошее непрерывное размещение однотипных одноразмерных данных. 
Теперь вместо перебирая одну структуру данных, мы должны рассмотреть несколько массивов. Что ж, код становится как-то уродливее, но то это неудобство, что приходится платить нам для лучшей производительности. Помните — это компромисс! Этот подход также известен как проектирование, ориентированное на данные (DoD).

КОНТЕЙЕНРЫ

1.Контейнеры Qt поддерживают неявное совместное использование, которое является названием для комбинации подсчета ссылок и копирование при записи (COW). Не стоит бояться возвращать их из метода по значению или передавать в метод так как это операция по копированию 4 байт в 32 битных и 8 байт в 64 битных системах. 

2. Основное различие между FOREACH и range-for, заключается в их разной работе. Первый это старый добрый фор, второй конструкция языка. Первый всегда гарантирует валидность итератора, даже при удалении обьектов из контейнера, т к копиб делаем. Второй этой гарантии дать не может, однако сильно упрощает код, особенно при линейном прохождении и использовании auto.

3. В своих моделях (для МВС) можно какие угодно контейнеры использовать, только не надо ими оперировать в сигналах, поскольку они будут создавать копии при межтредовом взаимодействии, здесь надо отдавать предпочтение Qt  контейнерам.

4. explicitly shared не даст контейнерам Qt быть на шаг впереди, они будут на шаг-два сзади. поэтому контейнеры - это не конек Qt, во всяком случае не конек в плане производительности. это просто кроссплатформенный обвес, который все больше и больше тянет назад...

5. смысл мувать cow контейнер - Чтобы отвязать старый инстанс от данных. Допустим, вы скопировали контейнер - это правда дешево для Qt, а потом решили пробежаться по нему в range-based for-loop без qAsConst() или зачем-то тронули его begin()/end(), произойдет  detach() с глубоким копированием. Не нужно шарить владение когда ненужно.

6. Если вы находитесь на земле Qt, используйте код Qt'ians. Это не только для удобства чтения / согласованности. Подумайте, что произойдет, если вы сохраните все в контейнере stl, тогда вам придется передать все эти данные в функцию Qt. Вы действительно хотите управлять кучей кода, который копирует вещи в / из контейнеров Qt. Ваш код уже сильно зависит от Qt, так что вы не делаете его более «стандартным» с помощью контейнеров stl. И какой смысл в контейнере, если каждый раз, когда вы хотите использовать его для чего-то полезного, вы должны скопировать его в соответствующий контейнер Qt?

7. В Qt программах активно используют COW, который реализую все контейнеры Qt, поэтому все стараются сидеть на Qt контейнерах, вопрос встается остро особенно в многопоточной  среде, когда надо передать результат асинхронной операции в UI, там COW позволяет избежать накладных расходов на копирование.
8. 

ЮАЙ

ВИДЖЕТЫ ИЛИ КУМЛЬ

1.  Большой и долгий проект, при котором 5.15 уже прекратит поддержку. Что касается конкретно Qt6 мне понравился полный переход на cmake, что позволило без особых трудностей ужать фреймворк до 100Мб и улучшения по коду  для qml. Виджеты не использую уже давно. Недавно потребовалось мелкое приложение на виджетах сделать - думал помру от неудобства.

2. На десктопе предпочтительней стандартные виджеты, а не вот это qml  ная отсебятина
3. 

1. Любое отображение данных через MVC (model-view-controller). В Qt эту штуку обозвали Модель-Представление, слегка сместив обязанности, ибо GUI смешивает отображение и контроллер, но по факту те же яйца.

2. Никогда не смешиваем данные, логику и отображение (в дополнение к предыдущему пункту).
Должна быть возможность в любой момент получат данные как по сети, так и из бд. Да хоть из файлика. И отображать их хоть на консоль, хоть в виде данных.

3. Если юзаешь qml — никакой js логики. Js только для настройки отображение. Всё что больше — пишем отдельную прокси-модель на плюсах, и регаем в QML.

4. Если юзаешь виджеты — максимальное переиспользование, и максимальное абстрагирование классов от изначальной задачи.
