# Qt-Advices

Перевод советов от китайца
https://github.com/andr1312e/Qt-Advices/tree/main/feiyangqingyun#readme

гугл стайл чистого кода
https://evgenykislov.com/wp-content/custom/cpp_codestyle/cppguide_ru.html

1-7 строки
Russian qt advices советы кути русский по русски рекомендации кутэ

1. Проблема со строковыми классами ```QString``` в целом заключается в том, что они копируют содержимое  char* при их создании. ```QByteArray``` представляет собой последовательность байтов без какой-либо кодировки, поэтому ее можно
рассматривается как эквивалент ```std::string```. Используйте его для хранения байтовых массивов. Его конструкторы будут брать внутренний буфер и копировать его. Если мы хотим избежать этой копии, мы можем использовать функцию ```fromRawData()```,
который будет хранить только указатель на данные, но не станет владельцем.
Вызывающий обьект должен гарантировать, что указанные данные остаются действительными для всего времени жизни ```QByteArray```. Другой возможностью является использование макроса ```QByteArrayLiteral()```. Этот макрос будет
сгенерируйте QByteArray из литерала char* во время компиляции и поместите его в сегмент памяти только для чтения.
2. ```QString``` представляет строку Unicode в кодировке UTF-16 и поддерживает кодировку Unicode. Он неявно используется совместно (подсчет ссылок), и его конструкторы будут выделять
объем памяти один раз. Аналогично ```QByteArray```, если мы хотим сэкономить выделения памяти, мы можем использовать  ```fromRawData()``` функцией или макросом ```QStringLiteral()```.
Существует дополнительный строковый класс под названием ```QLatin1String```, который обеспечивает тонкую оболочку вокруг ASCII-закодированных литералов char*. Он подразумевается как
оптимизация, чтобы избежать построения объекта ```QString```. Однако русская кириллица не поддерживается.Так как этот класс не является строкой Unicode, она будет использовать половину памяти эквивалентного
```QString```.
3.  Qt предоставляет  класс, называемый ```QStringBuilder```, обеспечивающий базовую оптимизацию  для конкатенации ```QString```. Этот класс не предназначен для создания экземпляров
напрямую, но будет автоматически вызываться, когда его перегруженный оператор % используется вместо обычного оператора конкатенации +, как в следующем
пример:

```cpp
QString s1("Привет");
QLatin1String s2 («вы все»);
QString msg = s1 % s2 % "как дела?";
```
Установив глобальную опцию ```QT_USE_STRING_BUILDER```, оператор конкатенации + всегда будет автоматически заменяться классом шаблона QStringBuilder, и вам не нужно вручную изменять код, чтобы извлечь из этого пользу.

```cpp
DEFINES +=                 \
  DQT_NO_URL_CAST_FROM_STRING\
  QT_USE_STRING_BUILDER \
```

4. В Qt 4 уже был класс, инкапсулирующий подстроки заданной строки, с именем ```QStringRef```. Он не хранит никаких данных, кроме указателей на часть ```QString```. Таким образом, подстроки могут быть дешево переданы без выделения новой памяти. Пример этого класса:
```
QString s("альфа, бета, гамма, дзета");
QVector<QStringRef> alfaBet = s.splitRef(", "); // вместо split()!
```
Однако в Qt 5.10 был введен новый класс для представления подстрок, а именно класс ```QStringView```, созданный по образцу C++17 ```std::string_view```. Разница между этими двумя классами в том, что ```QStringRef``` требует ```QString```
экземпляр в качестве источника, в то время как QStringView обеспечивает представление произвольного UTF-16 как из строк, так и строкового литерала. Из-за разной реализации, QStringRef устарел и вырезан в 6 версии. 

5. Многие знают, что все строки с одинаковым содержимым разделяют одну и ту же память. Это круто, потому что экономит место, но также позволяет быстро сравнивать строки на равенство путем сравнения только указателей. Реализация довольно проста, пример на чситом с++
```cpp
template <char... String> struct Interned
{
static constexpr char const value[sizeof...(String) + 1]{String...};
};
template <char... String> constexpr char const Interned<String...>::value[];

template<typename CharT, CharT ...String>
constexpr const char* operator""_intern()
{
return (Interned<String...>::value);
}
// test: only one copy?
static_assert("foo"_intern == "foo"_intern, ""); 
```
Литерал char* упаковывается в тип и представляется указатель на (один и единственный) статический член типа-оболочки. GCC скомпилирует этот код только в режиме C++14! Интернирование — всего лишь один из вариантов классического шаблона проектирования Gang of Four (GoF) Приспособленец. Этот шаблон определяет легковесные прокси, которые избегают дублирования часто используемых объектов, и это то, чего мы хотим достичь с интернированием. Библиотека ```Boost.Flyweight``` реализует этот шаблон, и мы могли бы использовать его  следующим образом: ```boost::flyweight<std::string>```.

6. Когда в вашей программе преобладает поиск подстрок, то разумно использовать новые алгоритмы, один из которых уже доавлен в C++17 . Речь идет об алгоритме Бойера-Море-Хорспула, который часто работает быстрее стандартного stl-поиска. Этот алгоритм не проверяет каждый символ строки, пытается пропустить некоторые из них, используя таблицу, сгенерированную из строки. Посмотрите на следующий пример его использования: 
```cpp
QString text = "Lorem ipsum dolor sit amet, consectetur adipiscing ...";
QString needle ="amet";
auto iter = std::search(text.constBegin(), text.constEnd(),
std::boyer_moore_searcher(
needle.constBegin(), needle.constEnd()));
```
В 11 версии с++ мы можем использовать ```Boost``` реализацию ```Boyer-More-Horspool``` алгоритм поиска строки. Как всегда у причудливых алгоритмов есть цена в виде создания строковой таблицы, поэтому этот алгоритм принесет улучшения производительности только для больших строк. 

7. Если мы хотим избежать выделения памяти, мы могли бы просто использовать const char*,  в стиле C. Однако это не очень удобно. К счастью, библиотека стандартных шаблонов EASTL, содержит фиксированный размер строк, который не будет выделять дополнительную память, а именно ```eastl::fixed_string```. Вы можете установить максимальный объем памяти, который будет используется, а для критических случаев также может быть включено динамическое распределение. Мы могли бы также использовать ```QStringLiteral``` для строки фиксированного размера. [статья про литерал](https://www.pvsm.ru/c-3/8497)
8. 
9.4343


